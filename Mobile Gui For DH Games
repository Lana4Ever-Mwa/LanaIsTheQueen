local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Mobile Supported GUI",
   LoadingTitle = "GUI For Mobile Players",
   LoadingSubtitle = "By JJ",
   Theme = "Light", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   DisableRayfieldPrompts = true,
   DisableBuildWarnings = true, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Mobile Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local MainTab = Window:CreateTab("Main", "sparkles")
local MainSection = MainTab:CreateSection("Main")

local Paragraph = MainTab:CreateParagraph({Title = "Scripts Warning:", Content = "Some scripts may cause a permanent ban on Da Hood games...SO BEWARE!"})
local Divider = MainTab:CreateDivider()

   local Dropdown = MainTab:CreateDropdown({
   Name = "Themes",
   Options = {"Bloom","Serenity","Amethyst","Ocean","AmberGlow","DarkBlue","Green","Light","Default"},
   CurrentOption = {"Light"},
   MultipleOptions = false,
   Flag = "Dropdown1",
   Callback = function(Options)
   Window.ModifyTheme(Options[1])
   end,
})

local Divider = MainTab:CreateDivider()

local LocksTab = Window:CreateTab("Locks", "lock-keyhole")
local LocksSection = LocksTab:CreateSection("Locks")

    Rayfield:Notify({
   Title = "You've exucuted the GUI!",
   Content = "Enjoy!",
   Duration = 3,
   Image = "heart",
})

local Button = LocksTab:CreateButton({
   Name = "Silent Aim-Resolver",
   getgenv().khen = {
    ['Silent'] = {
        Normal = {
            Enabled = true,
            HitPart = "HumanoidRootPart",
            Prediction = 0.1657724,
            AirPrediction = 0.149,
        },
        FOV = {
            FOVSize = 130,
            ShowFOV = true,
        },
        Resolver = {
            Enabled = true,
        }
    },
}

loadstring(game:HttpGet("https://raw.githubusercontent.com/khenn791/script-khen/refs/heads/main/SilentAim", true))();

local Button = LocksTab:CreateButton({
   Name = "Vascal Silent Aim",
   loadstring(game:HttpGet("https://raw.githubusercontent.com/Gwaporoblox/VascalSilentaim/main/README.md"))()

local Button = LocksTab:CreateButton({
   Name = "Vascal CamLock",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/Stomp-Shop-Da-Strike-PSXbox-Vascal-Lock-14629"))()
   end,
})

local Button = LocksTab:CreateButton({
   Name = "BaldsLock",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/sdfesdfsedf/srgtergasdfs/main/wwwwwww", true))()
   end,
})

local Button = LocksTab:CreateButton({
   Name = "Ace CamLock",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/Totocoems/Ace/main/Ace"))()
   end,
})

local Button = LocksTab:CreateButton({
   Name = "Carlcc CamLock",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/28asjdjasdkj/adsadasdw234dasd/refs/heads/main/GODISGREAT"))()
   end,
})

local AntiLockTab = Window:CreateTab("AntiLock", "shield-alert")
local Section = AntiLockTab:CreateSection("AntiLocks")

local Button = AntiLockTab:CreateButton({
   Name = "Kirbsware AntiLock",
   Callback = function()
   loadstring(game:HttpGet('https://raw.githubusercontent.com/wenny69420/KirbswareScripts/main/MobileV3'))()
   end,
})

local FlyScriptsTab = Window:CreateTab("FlyScripts", "plane")
local Section = FlyScriptsTab:CreateSection("FlyScripts")

local Button = FlyScriptsTab:CreateButton({
   Name = "Flying Script IOS",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/scripthubekitten/dahoodios/main/hoodcustomfly", true))()
   end,
})

local Button = FlyScriptsTab:CreateButton({
   Name = "Flying Script",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-Fly-script-v3-16742"))()
   end,
})

local Button = FlyScriptsTab:CreateButton({
   Name = "Xora Flying Script",
   Callback = function()
   -- Fly [ NEW! ]
loadstring(Game:HttpGet("https://raw.githubusercontent.com/TheRealXORA/Roblox/refs/heads/Main/Scripts%20/Universal%20/Fly.lua", true))()
   end,
})

local UseFulTab = Window:CreateTab("UseFul", "infinity")
local Section = UseFulTab:CreateSection("UseFul Things")

local Button = UseFulTab:CreateButton({
   Name = "RightClick",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/DHBCommunity/DHBOfficialScript/main/RightClick"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Chat Spammer",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/IncognitoChat-Hangout-or-UNIVERSAL-V2-17194"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Chat Bypass",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/shadow62x/catbypass/main/upfix"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Mobile Macro #1",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/DHBCommunity/DHBOfficialScript/main/macromobbyballigusapo"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Mobile Macro #2",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/DHBCommunity/DHBOfficialScript/main/MacroBalli"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Mobile Macro #3",
   Callback = function()
   getgenv().Depart = {
    ["Aimbot"] = {
        ["Enabled"] = false,
        ["Notifications"] = false,
        ["PINGBASED"] = false,
        ["PredictionValue"] = 0.129,
        ["Radius"] = 150,
        ["AirPrediction"] = 0.14633
    },
    ["AimbotCamlock"] = {
        ["Smoothness"] = 0,
        ["AirSmoothness"] = 0.217,
        ["Campred"] = 0.449,
        ["ShakeValue"] = 0,
        ["AimPart"] = "HumanoidRootPart"
    },
    ["FOVSettings"] = {
        ["FOVVisible"] = false,
        ["FOVSize"] = 150
    },
    ["Checks"] = {
        ["FriendCheck"] = false,
        ["UnlockOnKO"] = true,
        ["AntiGroundShots"] = true
    },
    ["Visuals"] = {
        ["Line"] = false,
        ["Highlight"] = false,
        ["Emoji"] = false,
        ["EmojiType"] = "ðŸ¥µ"
    },
    ["BulletRedirection"] = { 
        ["Enabled"] = false,
        ["HitPart"] = "HumanoidRootPart",
        ["AirPart"] = "Head",
        ["Prediction"] = 0.14633,
        ["AirPrediction"] = 0.129,
        ["FOV"] = {
            ["Visible"] = false,
            ["Size"] = 150
        },
        ["Checks"] = {
            ["WallCheck"] = true,
            ["FriendCheck"] = false,
            ["KOCheck"] = true,
            ["AntiGroundShots"] = true
        },
        ["Hitchance"] = {
            ["Value"] = 100
        }
    },
    ["Triggerbot"] = {
        ["Enabled"] = false,
        ["Delay"] = 0,
        ["TapDelay"] = 0.01,
        ["UsePrediction"] = true,
        ["Prediction"] = 0.125,
        ["Tolerance"] = 15,
        ["Distance"] = 300,
        ["FOVSize"] = 150,
        ["FOVShow"] = false,
        ["Whitelisted"] = {"[Double-Barrel SG]", "[DoubleBarrel]", "[Revolver]", "[TacticalShotgun]"},
        ["UseWhitelist"] = true, 
        ["AimParts"] = {"HumanoidRootPart", "Head"},
        ["WallCheck"] = true,
        ["KOCheck"] = true
    },
    ["Utility"] = {
        ["Tool"] = false,
        ["Button"] = true,
        ["ButtonSize"] = 10,
        ["Macro"] = true
    }
}

-- credits to chatgpt tapn with the method
--dont laugh at how gen it is i just used teh method

wait(0.5)
getgenv().Depart = getgenv().Depart
local plr = game:GetService("Players").LocalPlayer



local cclosure = syn_newcclosure or newcclosure or nil



if not cclosure or not hookmetamethod then

   plr:Kick("\n\nYour exploit doesn't support hookmetamethod\n")

end



local oldNamecall

oldNamecall = hookmetamethod(game, "__namecall", cclosure(function(self,...)

   local NamecallMethod = getnamecallmethod()

   local args = {...}

   

   if (NamecallMethod == "Kick" or NamecallMethod == "kick") and not checkcaller() then

       if self ~= plr then

           return oldNamecall(self,...)

       end

       return

   end

   

   return oldNamecall(self,...)

end))
        local function playIntro()
            local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")

            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = "IntroScreen"
            screenGui.Parent = playerGui

            local frame = Instance.new("Frame")
            frame.Name = "IntroFrame"
            frame.Parent = screenGui
            frame.Size = UDim2.new(1, 0, 1, 0)
            frame.BackgroundTransparency = 1

            local imageLabel = Instance.new("ImageLabel")
            imageLabel.Name = "Living Legend"
            imageLabel.Parent = frame
            imageLabel.Size = UDim2.new(0.4, 0, 0.4, 0)
            imageLabel.Position = UDim2.new(0.3, 0, 0.3, 0)
            imageLabel.Image = "rbxassetid://83310144482533"
            imageLabel.BackgroundTransparency = 1
            imageLabel.ImageTransparency = 1

            local sound = Instance.new("Sound")
            sound.Name = "IntroSound"
            sound.Parent = frame
            sound.SoundId = "rbxassetid://14843357644"
            sound.Volume = 15
            sound:Play()

            local tweenService = game:GetService("TweenService")

            local blurEffect = Instance.new("BlurEffect")
            blurEffect.Parent = game.Lighting
            blurEffect.Size = 10

            local tweenInfo = TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

            local fadeIn = tweenService:Create(imageLabel, tweenInfo, {ImageTransparency = 0.5})
            local fadeOut = tweenService:Create(imageLabel, tweenInfo, {ImageTransparency = 1})
            local blurTween = tweenService:Create(blurEffect, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = 0})

            fadeIn:Play()
            fadeIn.Completed:Wait()

            wait(2)

            fadeOut:Play()
            fadeOut.Completed:Wait()

            blurTween:Play()
            blurTween.Completed:Wait()

            blurEffect:Destroy()
            screenGui:Destroy()
        end

        playIntro()
        
wait(0.5)
print("Loaded!")
if Depart.Aimbot.Enabled then
local CC = game:GetService("Workspace").CurrentCamera
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()
local placemarker = Instance.new("Part", game.Workspace)
placemarker.Anchored = true
placemarker.CanCollide = false
placemarker.Size = Vector3.new(6, 6, 6)
placemarker.Transparency = 1

local AimlockState = false
local Victim = nil
local Plr
local function shouldLockOntoPlayer(targetPlayer)
    -- If FriendCheck is enabled and the target is a friend, do not lock onto the player
    if Depart.Checks.FriendCheck then
        -- If FriendCheck is enabled and the target is a friend, return false to avoid locking onto friends
        if isFriend(targetPlayer) then
            return false
        end
    end
    -- If FriendCheck is disabled, allow locking onto friends
    return true
end


local function Notify(text)
    game.StarterGui:SetCore("SendNotification", {
        Title = "Notification",
        Text = text,
        Duration = 2,
    })
end

local highlightInstance  -- Variable to hold the highlight instancegg

local function highlightPlayer(targetPlayer)
    if targetPlayer.Character then
        local highlight = Instance.new("Highlight")
        highlight.Parent = targetPlayer.Character
        highlight.FillColor = Color3.fromRGB(127, 0, 255)  -- Set the highlight color
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)  -- Set the outline color
        highlight.FillTransparency = 0.5  -- Set the transparency
        highlight.OutlineTransparency = 0.5  -- Set the outline transparency
        return highlight
    end
end




local function lockOntoPlayer(player)
    Plr = player
    AimlockState = true
    if Depart.Aimbot.Notifications then
        Notify("Locked On: " .. tostring(Plr.Name))
    end

    -- Apply highlight if Visuals.Highlight is enabled
    if Depart.Visuals.Highlight and player.Character then
        highlightInstance = highlightPlayer(player)  -- Call the highlight function
    end

    -- Create and show emoji if Emoji is enabled
    if Depart.Visuals.Emoji then
        if not emojiLabel then
            createEmoji()  -- Create emoji if it doesn't exist
        end
    end
end

local function unlockPlayer()
    AimlockState = false
    Plr = nil
    
    if Depart.Aimbot.Notifications then
        Notify("Unlocked")
    end
end

if Depart.Aimbot.PINGBASED then
    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
    ping = tonumber(string.split(ping, '(')[1]) or 0 -- Safe parse
    
    if ping < 10 then
        Depart.Aimbot.PredictionValue = 0.10087127181718181 -- For pings below 10ms
    elseif ping < 20 then
        Depart.Aimbot.PredictionValue = 0.10087127181718181 -- Same as original for 10-20ms range
    elseif ping < 30 then
        Depart.Aimbot.PredictionValue = 0.11027333333333333 -- Updated for 20-30ms
    elseif ping < 40 then
        Depart.Aimbot.PredictionValue = 0.11561500000000001 -- Updated for 30-40ms
    elseif ping < 50 then
        Depart.Aimbot.PredictionValue = 0.12109333333333334 -- Updated for 40-50ms
    elseif ping < 60 then
        Depart.Aimbot.PredictionValue = 0.12670833333333334 -- Updated for 50-60ms
    elseif ping < 70 then
        Depart.Aimbot.PredictionValue = 0.13246 -- Updated for 60-70ms
    elseif ping < 80 then
        Depart.Aimbot.PredictionValue = 0.13834833333333335 -- Updated for 70-80ms
    elseif ping < 90 then
        Depart.Aimbot.PredictionValue = 0.14437333333333335 -- Updated for 80-90ms
    elseif ping < 100 then
        Depart.Aimbot.PredictionValue = 0.15053500000000003 -- Updated for 90-100ms
    elseif ping < 110 then
        Depart.Aimbot.PredictionValue = 0.15683333333333335 -- Updated for 100-110ms
    elseif ping < 120 then
        Depart.Aimbot.PredictionValue = 0.16326833333333332 -- Updated for 110-120ms
    elseif ping < 130 then
        Depart.Aimbot.PredictionValue = 0.16984 -- Updated for 120-130ms
    elseif ping < 140 then
        Depart.Aimbot.PredictionValue = 0.17654833333333333 -- Updated for 130-140ms
    elseif ping < 150 then
        Depart.Aimbot.PredictionValue = 0.18339333333333335 -- Updated for 140-150ms
    elseif ping < 160 then
        Depart.Aimbot.PredictionValue = 0.190375 -- Updated for 150-160ms
    elseif ping < 170 then
        Depart.Aimbot.PredictionValue = 0.19749333333333333 -- Updated for 160-170ms
    elseif ping < 180 then
        Depart.Aimbot.PredictionValue = 0.20474833333333334 -- Updated for 170-180ms
    elseif ping < 190 then
        Depart.Aimbot.PredictionValue = 0.21214 -- Updated for 180-190ms
    elseif ping < 200 then
        Depart.Aimbot.PredictionValue = 0.21966833333333335 -- Updated for 190-200ms
    else
        Depart.Aimbot.PredictionValue = 0.22733333333333333 -- For pings above 200ms
    end
end




local function isFriend(player)
    return player:IsFriendsWith(game.Players.LocalPlayer.UserId)
end
local function unlockIfKOedOrFriend(victim)
    local koCheck = victim.Character:FindFirstChild("BodyEffects") and victim.Character.BodyEffects:FindFirstChild("K.O")
    local grabbedCheck = victim.Character:FindFirstChild("GRABBING_CONSTRAINT")
    
    -- Check if the target is K.O. or grabbed, and also utilize the shouldLockOntoPlayer check
    if (koCheck and koCheck.Value) or grabbedCheck or not shouldLockOntoPlayer(victim) then
        AimlockState = false
        Victim = nil
    end
end



game:GetService("RunService").Heartbeat:Connect(function()
    if AimlockState and Victim then
        unlockIfKOedOrFriend(Victim)
    end
end)





local function getClosestPlayerInFOV()
    local closestPlayer = nil
    local shortestDistance = Depart.FOVSettings.FOVSize
    local screenCenter = Vector2.new(CC.ViewportSize.X / 2, CC.ViewportSize.Y / 2)
    local playerPosition = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position

    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("Humanoid") and otherPlayer.Character.Humanoid.Health > 0 then
            -- Check if the player should be locked onto, considering FriendCheck
            if shouldLockOntoPlayer(otherPlayer) then
                local humanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    local distance = (humanoidRootPart.Position - playerPosition).magnitude
                    if distance <= Depart.Aimbot.Radius then
                        local pos = CC:WorldToViewportPoint(humanoidRootPart.Position)
                        local fovPos = Vector2.new(pos.X, pos.Y)
                        local magnitude = (fovPos - screenCenter).magnitude
                        
                        if magnitude < Depart.FOVSettings.FOVSize and magnitude < shortestDistance then
                            closestPlayer = otherPlayer
                            shortestDistance = magnitude
                        end
                    end
                end
            end
        end
    end
    return closestPlayer
end


-- Create the Drawing line
local line = Drawing.new("Line")
line.Thickness = 2 -- Set the thickness of the line
line.Color = Color3.fromRGB(127, 0, 255) -- Set the color of the line (e.g., red)
line.Visible = false -- Initially not visible
line.Transparency = 1 -- Fully transparent initially




local emojiLabel -- Declare the emoji label variable

local function isTargetInAir(character)
    return character.Humanoid.FloorMaterial == Enum.Material.Air
end

local function updateAimlockAndMarker()
    if AimlockState and Victim and Victim.Character then
        local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            local aimPart = Depart.AimbotCamlock.AimPart
            local target = Victim.Character[aimPart]

            -- AntiGroundShots logic
            if Depart.Checks.AntiGroundShots and Victim.Character then
                local targetBone = Victim.Character:FindFirstChild(aimPart)
                if targetBone and targetBone.Velocity.Y < 0 then
                    targetBone.Velocity = Vector3.new(targetBone.Velocity.X, 0, targetBone.Velocity.Z)
                    targetBone.AssemblyLinearVelocity = Vector3.new(targetBone.Velocity.X, 0, targetBone.Velocity.Z)
                end
            end

            if target then
                -- Calculate the target's predicted position
                local targetVelocity = Victim.Character[aimPart].Velocity
                local predictedPosition = target.Position + (targetVelocity * Depart.Aimbot.PredictionValue)

                -- Use isTargetInAir to adjust prediction when the target is jumping
                if isTargetInAir(Victim.Character) then
                    predictedPosition = predictedPosition + (targetVelocity * Depart.Aimbot.AirPrediction)
                end

                local LookPosition = CFrame.new(CC.CFrame.p, predictedPosition)
                CC.CFrame = CC.CFrame:Lerp(LookPosition, Depart.AimbotCamlock.Smoothness)
                placemarker.CFrame = CFrame.new(Victim.Character.HumanoidRootPart.Position)

                -- Update emoji position if enabled
                if Depart.Visuals.Emoji then
                    if not emojiLabel then
                        emojiLabel = Drawing.new("Text")
                        emojiLabel.Text = Depart.Visuals.EmojiType
                        emojiLabel.Size = 30
                        emojiLabel.Color = Color3.fromRGB(135, 206, 235)
                    end
                    local targetScreenPos = CC:WorldToViewportPoint(predictedPosition)
                    emojiLabel.Position = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
                    emojiLabel.Visible = true
                end

                -- Calculate the 2D positions for the line drawing
                local targetScreenPos = CC:WorldToViewportPoint(Victim.Character.HumanoidRootPart.Position)
                local predictedScreenPos = CC:WorldToViewportPoint(predictedPosition)

                if Depart.Visuals.Line then
                    line.From = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
                    line.To = Vector2.new(predictedScreenPos.X, predictedScreenPos.Y)
                    line.Visible = true
                end
            end
        end
    else
        placemarker.CFrame = CFrame.new(0, 9999, 0)
        line.Visible = true

        if emojiLabel then
            emojiLabel.Visible = true
            emojiLabel:Destroy()
            emojiLabel = nil
        end
        if highlightInstance then
            highlightInstance:Destroy()
            highlightInstance = nil
        end
    end
end


game:GetService("RunService").RenderStepped:Connect(function()
    updateAimlockAndMarker()
end)

-- Create a Screen GUI for toggle button only if Button is enabled
if Depart.Utility.Button then
    local screenGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
    screenGui.ResetOnSpawn = false

    local toggleButton = Instance.new("ImageButton")
    toggleButton.Parent = screenGui
    local buttonSize = Depart.Utility.ButtonSize
    toggleButton.Size = UDim2.new(0, buttonSize, 0, buttonSize) -- Set both width and height to the same value
    toggleButton.Position = UDim2.new(0.5, -buttonSize / 2, 0.8, -buttonSize / 2) -- Center the button
    toggleButton.Image = "rbxassetid://18261026237" -- Replace with the actual image asset ID
    toggleButton.BackgroundTransparency = 1 -- Set to 1 for a transparent background


    local function toggleAimlock()
        if Depart.Aimbot.Enabled then
            AimlockState = not AimlockState
            if AimlockState then
                Victim = getClosestPlayerInFOV()
                if Victim then
                    lockOntoPlayer(Victim)
                else
                    unlockPlayer()
                end
            else
                unlockPlayer()
            end
        end
    end

    toggleButton.MouseButton1Click:Connect(toggleAimlock)

    -- Mobile Draggable Functionality
    local dragging, dragStart, startPos = true, nil, nil
    toggleButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = toggleButton.Position
        end
    end)

    toggleButton.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
            local delta = input.Position - dragStart
            toggleButton.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    toggleButton.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
        end
    end)
end
local tool
if Depart.Utility.Tool then
    tool = Instance.new("Tool")
    tool.Name = "LockTool"
    tool.RequiresHandle = false
    tool.Parent = player.Backpack
tool.Activated:Connect(function()
    if Depart.Aimbot.Enabled then
        AimlockState = not AimlockState
        if AimlockState then
            Victim = getClosestPlayerInFOV()
            if Victim then
                lockOntoPlayer(Victim)
            else
                unlockPlayer()
            end
        else
            unlockPlayer()
        end
    end
end)
end

spawn(function()
    placemarker.Anchored = true
    placemarker.CanCollide = false
    placemarker.Size = Vector3.new(6, 6, 6)
    placemarker.Transparency = 1
end)

-- Patch to prevent FPS drop
local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)
mt.__namecall = newcclosure(function(...)
    local args = {...}
    if AimlockState and getnamecallmethod() == "FireServer" then
        if args[2] == "UpdateMousePos" or args[2] == "MOUSE" or args[2] == "UpdateMousePosI2" or args[2] == "MousePosUpdate" then
            if Depart.Aimbot.Enabled and Plr and Plr.Character then
                args[3] = Plr.Character[Depart.AimbotCamlock.AimPart].Position + (Plr.Character[Depart.AimbotCamlock.AimPart].Velocity * Depart.Aimbot.PredictionValue) -- Prediction based on position
                return old(unpack(args))
            end
        end
    end
    return old(...)
end)

-- Clean-up on character removal
player.CharacterRemoving:Connect(function()
    if tool then
        tool.Parent = player.Backpack
    end
end)
end
if Depart.BulletRedirection.Enabled then
-- Define SafePlayers directly in the script
local SafePlayers = {
    "NO_HUSTLE", --
    "atomicccuser433",
}

-- Existing global variables for Bullet Redirection
getgenv().HitPart = getgenv().Depart["BulletRedirection"].HitPart
getgenv().AirPart = getgenv().Depart["BulletRedirection"].AirPart
getgenv().Prediction_BulletRedirection = getgenv().Depart["BulletRedirection"].Prediction
getgenv().AirPrediction_BulletRedirection = getgenv().Depart["BulletRedirection"].AirPrediction
getgenv().BulletRedirectionEnabled = getgenv().Depart["BulletRedirection"].Enabled
getgenv().BulletRedirectionShowFOV = getgenv().Depart["BulletRedirection"].FOV.Visible
getgenv().BulletRedirectionFOVSize = getgenv().Depart["BulletRedirection"].FOV.Size
getgenv().BulletRedirectionHitchance = getgenv().Depart["BulletRedirection"].Hitchance.Value / 100 -- Convert to a fraction

-- Create FOV Drawing for Bullet Redirection
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = getgenv().BulletRedirectionShowFOV
FOVCircle.Thickness = 2
FOVCircle.Color = Color3.fromRGB(246, 198, 208) -- Set stroke color to green
FOVCircle.NumSides = 100
FOVCircle.Radius = getgenv().BulletRedirectionFOVSize
FOVCircle.Position = Vector2.new(0, 0) -- Will be updated later
FOVCircle.Filled = false

-- Function to update FOV Drawing Position and Visibility
local function updateFOVCircle()
    if getgenv().BulletRedirectionShowFOV then
        FOVCircle.Visible = true
        FOVCircle.Radius = getgenv().BulletRedirectionFOVSize
        local centerScreenPosition = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
        FOVCircle.Position = centerScreenPosition -- Center it
    else
        FOVCircle.Visible = false
    end
end

-- Optimize to run FOV update less frequently
local FOVUpdateInterval = 0.1 -- Update FOV every 0.1 seconds
game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
    if FOVUpdateInterval <= 0 then
        updateFOVCircle()
        FOVUpdateInterval = 0.1 -- Reset interval
    else
        FOVUpdateInterval = FOVUpdateInterval - deltaTime
    end
end)

-- Function to check if the player is in the SafePlayers list
local function isSafePlayer(player)
    for _, safePlayer in pairs(SafePlayers) do
        if player.Name == safePlayer then
            return true
        end
    end
    return false
end

local function getClosestPlayerToCenter()
    local centerScreenPosition = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
    local closestPlayer
    local closestDistance = math.huge
    local localPlayer = game.Players.LocalPlayer
    local camera = workspace.CurrentCamera

    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            -- Check if player is safe
            if isSafePlayer(player) then
                continue
            end

            -- FriendCheck: Skip if player is a friend and FriendCheck is enabled
            if getgenv().Depart["BulletRedirection"].Checks.FriendCheck and localPlayer:IsFriendsWith(player.UserId) then
                continue
            end

            local playerRootPart = player.Character.HumanoidRootPart
            local screenPosition, onScreen = camera:WorldToViewportPoint(playerRootPart.Position)

            if onScreen then
                -- KOCheck: Skip if the player is knocked out and KOCheck is enabled
                local KOd = player.Character:FindFirstChild("BodyEffects") and player.Character.BodyEffects["K.O"].Value
                if getgenv().Depart["BulletRedirection"].Checks.KOCheck and KOd then
                    continue
                end

                local Grabbed = player.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil

                if not Grabbed then
                    -- WallCheck: Raycast to ensure no walls are blocking the view
                    if getgenv().Depart["BulletRedirection"].Checks.WallCheck then
                        local ray = Ray.new(camera.CFrame.Position, playerRootPart.Position - camera.CFrame.Position)
                        local part, position = workspace:FindPartOnRay(ray, localPlayer.Character, false, true)

                        if part and not part:IsDescendantOf(player.Character) then
                            continue
                        end
                    end

                    -- AntiGroundShots: Check if player is falling
                    if getgenv().Depart["BulletRedirection"].Checks.AntiGroundShots then
                        local yVelocity = playerRootPart.Velocity.Y
                        if yVelocity < 0 then -- Player is falling
                            playerRootPart.Velocity = Vector3.new(playerRootPart.Velocity.X, 0, playerRootPart.Velocity.Z) * 0.36
                        end
                    end

                    -- Calculate distance to center and update the closest player
                    local distance = (centerScreenPosition - Vector2.new(screenPosition.X, screenPosition.Y)).Magnitude
                    if distance < closestDistance and distance <= getgenv().BulletRedirectionFOVSize then
                        closestPlayer = player
                        closestDistance = distance
                    end
                end
            end
        end
    end

    return closestPlayer
end

local BulletRedirectionTarget = nil

-- Optimize target finding to run less frequently
local targetUpdateInterval = 0.2 -- Update target every 0.2 seconds
game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
    if targetUpdateInterval <= 0 then
        BulletRedirectionTarget = getClosestPlayerToCenter()
        targetUpdateInterval = 0.2 -- Reset interval
    else
        targetUpdateInterval = targetUpdateInterval - deltaTime
    end
end)

local function isTargetInAir(character)
    return character.Humanoid.FloorMaterial == Enum.Material.Air
end

local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)
mt.__namecall = newcclosure(function(...)
    local args = {...}
    if getgenv().BulletRedirectionEnabled and BulletRedirectionTarget ~= nil and BulletRedirectionTarget.Character and getnamecallmethod() == "FireServer" then
        if args[2] == "UpdateMousePos" or args[2] == "MOUSE" or args[2] == "UpdateMousePosI2" or args[2] == "MousePosUpdate" then
            local hitchance = math.random() <= getgenv().BulletRedirectionHitchance -- Now uses the fraction
            if hitchance then
                local targetPart = isTargetInAir(BulletRedirectionTarget.Character) and getgenv().AirPart or getgenv().HitPart
                local predictionValue = isTargetInAir(BulletRedirectionTarget.Character) and getgenv().AirPrediction_BulletRedirection or getgenv().Prediction_BulletRedirection

                args[3] = BulletRedirectionTarget.Character[targetPart].Position + (BulletRedirectionTarget.Character[targetPart].Velocity * predictionValue)
                return old(unpack(args))
            end
        end
    end
    return old(...)
end)
setreadonly(mt, true)
end
if Depart.Triggerbot.Enabled then
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local camera = workspace.CurrentCamera
local client = players.LocalPlayer

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 1
fovCircle.NumSides = 150
fovCircle.Radius = getgenv().Depart.Triggerbot.FOVSize
fovCircle.Color = Color3.fromRGB(0, 0, 0)
fovCircle.Transparency = 0.5
fovCircle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
fovCircle.Visible = getgenv().Depart.Triggerbot.FOVShow

local function TriggerbotVelocity(target, time)
    local position = target.Position
    local velocity = target.Velocity
    return position + velocity * time
end

local function PositionTolerance(position, tolerance)
    local screenPoint = camera:WorldToViewportPoint(position)
    local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    local distanceFromCenter = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude
    return distanceFromCenter <= tolerance
end

local function IsWithinDistance(player)
    local character = player.Character
    if not character then return false end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end

    local clientCharacter = client.Character
    local clientRootPart = clientCharacter and clientCharacter:FindFirstChild("HumanoidRootPart")
    if not clientRootPart then return false end

    local distance = (humanoidRootPart.Position - clientRootPart.Position).Magnitude
    return distance <= getgenv().Depart.Triggerbot.Distance
end

local function IsInFOV(player)
    local character = player.Character
    if not character then return false end

    for _, aimPartName in ipairs(getgenv().Depart.Triggerbot.AimParts) do
        local aimPart = character:FindFirstChild(aimPartName)
        if aimPart then
            local rootPosition = camera:WorldToViewportPoint(aimPart.Position)
            local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)

            if PositionTolerance(aimPart.Position, getgenv().Depart.Triggerbot.FOVSize) then
                return true
            end
        end
    end

    return false
end

local function IsWhitelisted(toolName)
    if not getgenv().Depart.Triggerbot.UseWhitelist then
        return true
    end
    
    for _, name in ipairs(getgenv().Depart.Triggerbot.Whitelisted) do
        if toolName == name then
            return true
        end
    end
    return false
end

local function WallCheck(target)
    local origin = camera.CFrame.Position
    local direction = (target.Position - origin).Unit
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {client.Character, target.Parent}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(origin, direction * (target.Position - origin).Magnitude, raycastParams)
    return result == nil
end

local function KOCheck(player)
    local KOd = player.Character:FindFirstChild("BodyEffects") and player.Character.BodyEffects["K.O"].Value
    local Grabbed = player.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
    return not (KOd or Grabbed)
end

local function TriggerBot()
    if getgenv().Depart.Triggerbot.Enabled then
        local clientCharacter = client.Character
        if clientCharacter then
            local tool = clientCharacter:FindFirstChildOfClass("Tool")
            if tool and IsWhitelisted(tool.Name) then
                for _, player in ipairs(players:GetPlayers()) do
                    if player ~= client and IsInFOV(player) and IsWithinDistance(player) then
                        local character = player.Character
                        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

                        if character and humanoidRootPart and (not getgenv().Depart.Triggerbot.WallCheck or WallCheck(humanoidRootPart)) and (not getgenv().Depart.Triggerbot.KOCheck or KOCheck(player)) then
                            local predictedPosition = humanoidRootPart.Position

                            if getgenv().Depart.Triggerbot.UsePrediction then
                                predictedPosition = TriggerbotVelocity(humanoidRootPart, getgenv().Depart.Triggerbot.Prediction)
                            end

                            if PositionTolerance(predictedPosition, getgenv().Depart.Triggerbot.Tolerance) then
                                wait(getgenv().Depart.Triggerbot.Delay)
                                tool:Activate()
                                wait(getgenv().Depart.Triggerbot.TapDelay)
                            end
                        end
                    end
                end
            end
        end
    end
end

runService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    fovCircle.Visible = getgenv().Depart.Triggerbot.FOVShow
end)

runService.Heartbeat:Connect(TriggerBot)
end
if Depart.Utility.Macro then
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local camera = game.Workspace.CurrentCamera
    local runService = game:GetService("RunService")
 
    local enabled = true -- Initially set to false
 
    -- Function to update the character's facing direction
    local function updateCharacterFacing()
        if enabled and character and character.PrimaryPart then
            local cameraCFrame = camera.CFrame
            local lookAtPosition = cameraCFrame.Position + cameraCFrame.LookVector * 100 -- 100 studs ahead of the camera
            lookAtPosition = Vector3.new(lookAtPosition.x, character.PrimaryPart.Position.y, lookAtPosition.z)
            character:SetPrimaryPartCFrame(CFrame.new(character.PrimaryPart.Position, lookAtPosition))
        end
    end
 
    -- Connect the update function to the RenderStepped event to update every frame
    runService.RenderStepped:Connect(updateCharacterFacing)
 
    -- Update the character when respawning
    player.CharacterAdded:Connect(function(newCharacter)
        character = newCharacter
        character:WaitForChild("PrimaryPart")
    end)
 
    local screenGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
    screenGui.Name = "MacroGui"
    screenGui.Enabled = true -- Show the GUI
    screenGui.ResetOnSpawn = false -- Ensures the GUI doesn't reset on player respawn
 
    -- Parent Frame (Draggable)
    local parentFrame = Instance.new("Frame", screenGui)
    parentFrame.Size = UDim2.new(0, 180, 0, 70) -- Moderate size
    parentFrame.Position = UDim2.new(0.9, -190, 0.95, -80) -- Adjusted position
    parentFrame.BackgroundColor3 = Color3.fromRGB(24, 24, 24)
    parentFrame.BorderSizePixel = 0
 
    local uiCornerParent = Instance.new("UICorner", parentFrame)
    uiCornerParent.CornerRadius = UDim.new(0, 10)
 
    -- Child Frame (Inside Parent)
    local frame = Instance.new("Frame", parentFrame)
    frame.Size = UDim2.new(1, -15, 1, -15)
    frame.Position = UDim2.new(0, 5, 0, 5)
    frame.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
    frame.BorderSizePixel = 0
 
    local uiCorner = Instance.new("UICorner", frame)
    uiCorner.CornerRadius = UDim.new(0, 10)
 
    -- Draggable support for the parent frame
    local function makeDraggable(frame)
        local dragging
        local dragInput
        local dragStart
        local startPos
 
        local function update(input)
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
 
        frame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = frame.Position
 
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = true
                    end
                end)
            end
        end)
 
        frame.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                dragInput = input
            end
        end)
 
        runService.Heartbeat:Connect(function()
            if dragging and dragInput then
                update(dragInput)
            end
        end)
    end
 
    makeDraggable(parentFrame)
 
    -- Button
    local toggleButton = Instance.new("TextButton", frame)
    toggleButton.Size = UDim2.new(1, 0, 1, 0)
    toggleButton.Text = "Macro: OFF"
    toggleButton.BackgroundColor3 = Color3.fromRGB(246, 198, 208)
    toggleButton.TextColor3 = Color3.fromRGB(246, 198, 208)
    toggleButton.Font = Enum.Font.SourceSansBold
    toggleButton.TextScaled = true
    toggleButton.BorderSizePixel = 0
 
    local buttonCorner = Instance.new("UICorner", toggleButton)
    buttonCorner.CornerRadius = UDim.new(0, 10)
 
    toggleButton.MouseButton1Click:Connect(function()
        enabled = not enabled
        toggleButton.Text = enabled and "Macro: ON" or "Macro: OFF"
        toggleButton.BackgroundColor3 = enabled and Color3.fromRGB(135, 206, 235) or Color3.fromRGB(135, 206, 235)
    end)
end
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "KeyBoard",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/advxzivhsjjdhxhsidifvsh/mobkeyboard/main/main.txt", true))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "ResolverLagsInSomeGames",
   Callback = function()
   local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer

local ScreenGui = Instance.new("ScreenGui")
local ToggleButton = Instance.new("TextButton")
local Frame = Instance.new("Frame")
local NotificationFrame = Instance.new("Frame")
local NotificationText = Instance.new("TextLabel")
local NotificationTitle = Instance.new("TextLabel")

ScreenGui.Name = "ToggleScriptGUI"
ScreenGui.ResetOnSpawn = false -- Prevent GUI from being destroyed on respawn
ScreenGui.Parent = localPlayer:WaitForChild("PlayerGui")

Frame.Name = "MainFrame"
Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 60)
Frame.Position = UDim2.new(0, 50, 0, 50)
Frame.Size = UDim2.new(0, 200, 0, 100)
Frame.Active = true
Frame.Draggable = true

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 16)
UICorner.Parent = Frame

local UIGradient = Instance.new("UIGradient")
UIGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0.00, Color3.fromRGB(10, 10, 40)),
    ColorSequenceKeypoint.new(1.00, Color3.fromRGB(40, 40, 80))
}
UIGradient.Parent = Frame

ToggleButton.Name = "ToggleButton"
ToggleButton.Parent = Frame
ToggleButton.BackgroundColor3 = Color3.fromRGB(0, 100, 255)
ToggleButton.Position = UDim2.new(0.1, 0, 0.3, 0)
ToggleButton.Size = UDim2.new(0.8, 0, 0.4, 0)
ToggleButton.Text = "Resolver: OFF"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.Font = Enum.Font.SourceSansBold
ToggleButton.TextSize = 18

local ButtonUICorner = Instance.new("UICorner")
ButtonUICorner.CornerRadius = UDim.new(0, 16)
ButtonUICorner.Parent = ToggleButton

local ButtonUIGradient = Instance.new("UIGradient")
ButtonUIGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 150, 255)),
    ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 50, 150))
}
ButtonUIGradient.Parent = ToggleButton

-- this shows the notification for the one who made it, skidders remove this but idc, you can change it, fuck skidders ???? 
NotificationFrame.Name = "NotificationFrame"
NotificationFrame.Parent = ScreenGui
NotificationFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
NotificationFrame.BackgroundTransparency = 0.5
NotificationFrame.Position = UDim2.new(0.5, -100, 0.5, -50)
NotificationFrame.Size = UDim2.new(0, 200, 0, 100)

local NotificationUICorner = Instance.new("UICorner")
NotificationUICorner.CornerRadius = UDim.new(0, 16)
NotificationUICorner.Parent = NotificationFrame

NotificationTitle.Name = "NotificationTitle"
NotificationTitle.Parent = NotificationFrame
NotificationTitle.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
NotificationTitle.BackgroundTransparency = 1
NotificationTitle.Size = UDim2.new(1, 0, 0.4, 0)
NotificationTitle.Font = Enum.Font.SourceSansBold
NotificationTitle.Text = "Resolver OP"
NotificationTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
NotificationTitle.TextSize = 24

NotificationText.Name = "NotificationText"
NotificationText.Parent = NotificationFrame
NotificationText.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
NotificationText.BackgroundTransparency = 1
NotificationText.Position = UDim2.new(0, 0, 0.4, 0)
NotificationText.Size = UDim2.new(1, 0, 0.6, 0)
NotificationText.Font = Enum.Font.SourceSans
NotificationText.Text = "Made By @ Ovni"  -- Changed here
NotificationText.TextColor3 = Color3.fromRGB(255, 255, 255)
NotificationText.TextSize = 18

wait(5)
NotificationFrame:Destroy()

local scriptEnabled = false
local connection

local function onHeartbeat()
    for _, Target in pairs(Players:GetPlayers()) do
        if Target ~= localPlayer and Target.Character then
            for _, Part in pairs(Target.Character:GetDescendants()) do
                if Part:IsA("BasePart") then
                    Part.Velocity = Target.Character.Humanoid.MoveDirection * 16
                    Part.AssemblyLinearVelocity = Target.Character.Humanoid.MoveDirection * 16
                end
            end
        end
    end
end

ToggleButton.MouseButton1Click:Connect(function()
    scriptEnabled = not scriptEnabled
    if scriptEnabled then
        ToggleButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        ToggleButton.Text = "Resolver: ON"
        ButtonUIGradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 255, 150)),
            ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 150, 50))
        }
        if not connection then
            connection = RunService.Heartbeat:Connect(onHeartbeat)
        end
    else
        ToggleButton.BackgroundColor3 = Color3.fromRGB(0, 100, 255)
        ToggleButton.Text = "Resolver: OFF"
        ButtonUIGradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 150, 255)),
            ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 50, 150))
        }
        if connection then
            connection:Disconnect()
            connection = nil
        end
    end
end)
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "FpsBoostandLagReducer",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-FpsBoost-9260"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "FpsBoostandLagReducer2",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-FPS-BOOST-2022-3864"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Azure ESP",
   Callback = function()
   -- esp.lua
--// Variables
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera
local cache = {}

local bones = {
    {"Head", "UpperTorso"},
    {"UpperTorso", "RightUpperArm"},
    {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"},
    {"UpperTorso", "LeftUpperArm"},
    {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "LowerTorso"},
    {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"},
    {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"},
    {"RightLowerLeg", "RightFoot"}
}

--// Settings
local ESP_SETTINGS = {
    BoxOutlineColor = Color3.new(246, 198, 208),
    BoxColor = Color3.new(1, 1, 1),
    FilledBoxColor = Color3.new(1, 1, 1),
    NameColor = Color3.new(135, 206, 235),
    HealthOutlineColor = Color3.new(0, 0, 0),
    HealthHighColor = Color3.new(0, 1, 0),
    HealthLowColor = Color3.new(1, 0, 0),
    HealthColor = Color3.new(1, 1, 1),
    AnimatedHealthBars = false,
    DistanceColor = Color3.new(1, 1, 1),
    HealthBasedColor = false,
    CharSize = Vector2.new(4, 6),
    Teamcheck = false,
    WallCheck = false,
    Enabled = true,
    ShowFilledBox = false,
    ShowBox = false,
    BoxType = "Normal",
    ShowName = true,
    ShowHealth = false,
    ShowDistance = false,
    ShowTracer = false,
    TracerThickness = 1,
    TracerPosition = "Bottom",
}

local function create(class, properties)
    local drawing = Drawing.new(class)
    for property, value in pairs(properties) do
        drawing[property] = value
    end
    return drawing
end

local function createEsp(player)
    local esp = {
        tracer = create("Line", {
            Thickness = ESP_SETTINGS.TracerThickness,
            Color = ESP_SETTINGS.TracerColor,
            Transparency = 1
        }),
        boxOutline = create("Square", {
            Color = ESP_SETTINGS.BoxOutlineColor,
            Thickness = 2,
            Filled = false
        }),
        box = create("Square", {
            Color = ESP_SETTINGS.BoxColor,
            Thickness = 1,
            Filled = false
        }),
        filledBox = create("Square", {
            Color = ESP_SETTINGS.BoxColor,
            Thickness = 1,
            Transparency = 0.3,
            Filled = true
        }),
        name = create("Text", {
            Color = ESP_SETTINGS.NameColor,
            Outline = true,
            Center = true,
            Size = 11
        }),
        healthOutline = create("Line", {
            Thickness = 3,
            Color = ESP_SETTINGS.HealthOutlineColor
        }),
        health = create("Line", {
            Thickness = 1
        }),
        distance = create("Text", {
            Color = Color3.new(1, 1, 1),
            Size = 12,
            Outline = true,
            Center = true
        }),
        boxLines = {},
    }

    cache[player] = esp
end

local function isPlayerBehindWall(player)
    local character = player.Character
    if not character then
        return false
    end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        return false
    end

    local ray = Ray.new(camera.CFrame.Position, (rootPart.Position - camera.CFrame.Position).Unit * (rootPart.Position - camera.CFrame.Position).Magnitude)
    local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, {localPlayer.Character, character})
    
    return hit and hit:IsA("Part")
end

local function removeEsp(player)
    local esp = cache[player]
    if not esp then return end

    for _, drawing in pairs(esp) do
        drawing:Remove()
    end

    cache[player] = nil
end

function lerp(a, b, t)
    return a + (b - a) * t
end


local function updateEsp()
    for player, esp in pairs(cache) do
        local character, team = player.Character, player.Team
        if character and (not ESP_SETTINGS.Teamcheck or (team and team ~= localPlayer.Team)) then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local head = character:FindFirstChild("Head")
            local humanoid = character:FindFirstChild("Humanoid")
            local isBehindWall = ESP_SETTINGS.WallCheck and isPlayerBehindWall(player)
            local shouldShow = not isBehindWall and ESP_SETTINGS.Enabled
            if rootPart and head and humanoid and shouldShow then
                local position, onScreen = camera:WorldToViewportPoint(rootPart.Position)
                if onScreen then
                    local hrp2D = camera:WorldToViewportPoint(rootPart.Position)
                    local charSize = (camera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 3, 0)).Y - camera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, 2.6, 0)).Y) / 2
                    local boxSize = Vector2.new(math.floor(charSize * 1.4), math.floor(charSize * 1.9))
                    local boxPosition = Vector2.new(math.floor(hrp2D.X - charSize * 1.4 / 2), math.floor(hrp2D.Y - charSize * 1.6 / 2))

                    if ESP_SETTINGS.ShowName and ESP_SETTINGS.Enabled then
                        esp.name.Visible = true
                        esp.name.Text = string.lower(player.Name)
                        esp.name.Position = Vector2.new(boxSize.X / 2 + boxPosition.X, boxPosition.Y - 16)
                        esp.name.Color = ESP_SETTINGS.NameColor
                    else
                        esp.name.Visible = false
                    end

                    if ESP_SETTINGS.ShowFilledBox and ESP_SETTINGS.Enabled then
                        esp.filledBox.Position = boxPosition
                        esp.filledBox.Size = boxSize
                        esp.filledBox.Color = ESP_SETTINGS.FilledBoxColor
                        esp.filledBox.Visible = true
                    else
                        esp.filledBox.Visible = false
                    end

                    if ESP_SETTINGS.ShowBox and ESP_SETTINGS.Enabled then
                        if ESP_SETTINGS.BoxType == "Normal" then
                            esp.boxOutline.Size = boxSize
                            esp.boxOutline.Position = boxPosition
                            esp.box.Size = boxSize
                            esp.box.Position = boxPosition
                            esp.box.Color = ESP_SETTINGS.BoxColor
                            esp.box.Visible = true
                            esp.boxOutline.Visible = true
                            for _, line in ipairs(esp.boxLines) do
                                line:Remove()
                            end
                        elseif ESP_SETTINGS.BoxType == "Corner" then
                            local lineW = (boxSize.X / 3)
                            local lineH = (boxSize.Y / 3)
                        
                            if #esp.boxLines == 0 then
                                for i = 1, 16 do
                                    local boxLine = create("Line", {
                                        Thickness = 1,
                                        Color = ESP_SETTINGS.BoxColor,
                                        Transparency = 1
                                    })
                                    esp.boxLines[#esp.boxLines + 1] = boxLine
                                end
                            end
                        
                            local boxLines = esp.boxLines
                        
                            -- outline
                            for i = 1, 8 do
                                boxLines[i].Thickness = 2
                                boxLines[i].Color = ESP_SETTINGS.BoxOutlineColor
                                boxLines[i].Transparency = 1
                            end
                        
                            boxLines[1].From = Vector2.new(boxPosition.X, boxPosition.Y)
                            boxLines[1].To = Vector2.new(boxPosition.X, boxPosition.Y + lineH)
                        
                            boxLines[2].From = Vector2.new(boxPosition.X, boxPosition.Y)
                            boxLines[2].To = Vector2.new(boxPosition.X + lineW, boxPosition.Y)
                        
                            boxLines[3].From = Vector2.new(boxPosition.X + boxSize.X - lineW, boxPosition.Y)
                            boxLines[3].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y)
                        
                            boxLines[4].From = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y)
                            boxLines[4].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y + lineH)
                        
                            boxLines[5].From = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y - lineH)
                            boxLines[5].To = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y)
                        
                            boxLines[6].From = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y)
                            boxLines[6].To = Vector2.new(boxPosition.X + lineW, boxPosition.Y + boxSize.Y)
                        
                            boxLines[7].From = Vector2.new(boxPosition.X + boxSize.X - lineW, boxPosition.Y + boxSize.Y)
                            boxLines[7].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y + boxSize.Y)
                        
                            boxLines[8].From = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y + boxSize.Y - lineH)
                            boxLines[8].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y + boxSize.Y)
                        
                            -- inline
                            for i = 9, 16 do
                                boxLines[i].From = boxLines[i - 8].From
                                boxLines[i].To = boxLines[i - 8].To
                                boxLines[i].Color = ESP_SETTINGS.BoxColor
                            end
                        
                            for _, line in ipairs(boxLines) do
                                line.Visible = true
                            end
                            esp.box.Visible = false
                            esp.boxOutline.Visible = false
                        end
                    else
                        esp.box.Visible = false
                        esp.boxOutline.Visible = false
                        for _, line in ipairs(esp.boxLines) do
                            line:Remove()
                        end
                        esp.boxLines = {}
                    end

                    if ESP_SETTINGS.ShowHealth and ESP_SETTINGS.Enabled then
                        esp.healthOutline.Visible = true
                        esp.health.Visible = true
                        local health = 0
                        if ESP_SETTINGS.AnimatedHealthBars then
                            health = lerp(health, player.Character.Humanoid.Health, 0.3)
                        else
                            health = player.Character.Humanoid.Health
                        end
                        local healthPercentage = health / player.Character.Humanoid.MaxHealth
                        local healthBarHeight = (health / player.Character.Humanoid.MaxHealth) * boxSize.Y
                        esp.healthOutline.From = Vector2.new(boxPosition.X - 6, boxPosition.Y + boxSize.Y + 1)
                        esp.healthOutline.To = Vector2.new(esp.healthOutline.From.X, esp.healthOutline.From.Y - boxSize.Y - 1)
                        esp.health.From = Vector2.new(boxPosition.X - 6, boxPosition.Y + boxSize.Y)
                        
                        esp.health.To = Vector2.new(boxPosition.X - 6, boxPosition.Y + boxSize.Y - healthBarHeight) + Vector2.new(0, 1)
                        if ESP_SETTINGS.HealthBasedColor then
                            esp.health.Color = ESP_SETTINGS.HealthLowColor:Lerp(ESP_SETTINGS.HealthHighColor, healthPercentage)
                        else
                            esp.health.Color = ESP_SETTINGS.HealthColor
                        end
                    else
                        esp.healthOutline.Visible = false
                        esp.health.Visible = false
                    end

                    if ESP_SETTINGS.ShowDistance and ESP_SETTINGS.Enabled then
                        local distance = (localPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
                        esp.distance.Text = string.format("%.1f studs", distance)
                        esp.distance.Position = Vector2.new(boxPosition.X + boxSize.X / 2, boxPosition.Y + boxSize.Y + 5)
                        esp.distance.Color = ESP_SETTINGS.DistanceColor
                        esp.distance.Visible = true
                    else
                        esp.distance.Visible = false
                    end             

                    if ESP_SETTINGS.ShowTracer and ESP_SETTINGS.Enabled then
                        local tracerY
                        if ESP_SETTINGS.TracerPosition == "Top" then
                            tracerY = 0
                        elseif ESP_SETTINGS.TracerPosition == "Middle" then
                            tracerY = camera.ViewportSize.Y / 2
                        else
                            tracerY = camera.ViewportSize.Y
                        end
                        if ESP_SETTINGS.Teamcheck and player.TeamColor == localPlayer.TeamColor then
                            esp.tracer.Visible = false
                        else
                            esp.tracer.Visible = true
                            esp.tracer.From = Vector2.new(camera.ViewportSize.X / 2, tracerY)
                            esp.tracer.To = Vector2.new(hrp2D.X, hrp2D.Y)
                            esp.tracer.Color = ESP_SETTINGS.TracerColor
                            esp.tracer.Thickness = ESP_SETTINGS.TracerThickness
                        end
                    else
                        esp.tracer.Visible = false
                    end
                else
                    for _, drawing in pairs(esp) do
                        drawing.Visible = false
                    end
                    for _, line in ipairs(esp.boxLines) do
                        line:Remove()
                    end
                    esp.boxLines = {}
                end
            else
                for _, drawing in pairs(esp) do
                    drawing.Visible = false
                end
                for _, line in ipairs(esp.boxLines) do
                    line:Remove()
                end
                esp.boxLines = {}
            end
        else
            for _, drawing in pairs(esp) do
                drawing.Visible = false
            end
            for _, line in ipairs(esp.boxLines) do
                line:Remove()
            end
            esp.boxLines = {}
        end
    end
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= localPlayer then
        createEsp(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= localPlayer then
        createEsp(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    removeEsp(player)
end)

RunService.RenderStepped:Connect(updateEsp)
return ESP_SETTINGS
   end,
})


local Button = UseFulTab:CreateButton({
   Name = "ESP 1",
   Callback = function()
   loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Esp-open-source-15582"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Box ESP",
   Callback = function()
   --// Universal Box ESP (Works on Arsenal and other games)
 
-- settings
local settings = {
   defaultcolor = Color3.fromRGB(255,0,0),
   teamcheck = false,
   teamcolor = true
};
 
-- services
local runService = game:GetService("RunService");
local players = game:GetService("Players");
 
-- variables
local localPlayer = players.LocalPlayer;
local camera = workspace.CurrentCamera;
 
-- functions
local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new;
local tan, rad = math.tan, math.rad;
local round = function(...) local a = {}; for i,v in next, table.pack(...) do a[i] = math.round(v); end return unpack(a); end;
local wtvp = function(...) local a, b = camera.WorldToViewportPoint(camera, ...) return newVector2(a.X, a.Y), b, a.Z end;
 
local espCache = {};
local function createEsp(player)
   local drawings = {};
 
   drawings.box = newDrawing("Square");
   drawings.box.Thickness = 1;
   drawings.box.Filled = false;
   drawings.box.Color = settings.defaultcolor;
   drawings.box.Visible = false;
   drawings.box.ZIndex = 2;
 
   drawings.boxoutline = newDrawing("Square");
   drawings.boxoutline.Thickness = 3;
   drawings.boxoutline.Filled = false;
   drawings.boxoutline.Color = newColor3();
   drawings.boxoutline.Visible = false;
   drawings.boxoutline.ZIndex = 1;
 
   espCache[player] = drawings;
end
 
local function removeEsp(player)
   if rawget(espCache, player) then
       for _, drawing in next, espCache[player] do
           drawing:Remove();
       end
       espCache[player] = nil;
   end
end
 
local function updateEsp(player, esp)
   local character = player and player.Character;
   if character then
       local cframe = character:GetModelCFrame();
       local position, visible, depth = wtvp(cframe.Position);
       esp.box.Visible = visible;
       esp.boxoutline.Visible = visible;
 
       if cframe and visible then
           local scaleFactor = 1 / (depth * tan(rad(camera.FieldOfView / 2)) * 2) * 1000;
           local width, height = round(4 * scaleFactor, 5 * scaleFactor);
           local x, y = round(position.X, position.Y);
 
           esp.box.Size = newVector2(width, height);
           esp.box.Position = newVector2(round(x - width / 2, y - height / 2));
           esp.box.Color = settings.teamcolor and player.TeamColor.Color or settings.defaultcolor;
 
           esp.boxoutline.Size = esp.box.Size;
           esp.boxoutline.Position = esp.box.Position;
       end
   else
       esp.box.Visible = false;
       esp.boxoutline.Visible = false;
   end
end
 
-- main
for _, player in next, players:GetPlayers() do
   if player ~= localPlayer then
       createEsp(player);
   end
end
 
players.PlayerAdded:Connect(function(player)
   createEsp(player);
end);
 
players.PlayerRemoving:Connect(function(player)
   removeEsp(player);
end)
 
runService:BindToRenderStep("esp", Enum.RenderPriority.Camera.Value, function()
   for player, drawings in next, espCache do
       if settings.teamcheck and player.Team == localPlayer.Team then
           continue;
       end
 
       if drawings and player ~= localPlayer then
           updateEsp(player, drawings);
       end
   end
end)

   end,
})

local Button = UseFulTab:CreateButton({
   Name = "esp highlight",
   Callback = function()
   local FillColor = Color3.fromRGB(180,220,255)
local DepthMode = "AlwaysOnTop"
local FillTransparency = 0.5
local OutlineColor = Color3.fromRGB(255,255,255)
local OutlineTransparency = 0

local CoreGui = game:FindService("CoreGui")
local Players = game:FindService("Players")
local lp = Players.LocalPlayer
local connections = {}

local Storage = Instance.new("Folder")
Storage.Parent = CoreGui
Storage.Name = "Highlight_Storage"

local function Highlight(plr)
    local Highlight = Instance.new("Highlight")
    Highlight.Name = plr.Name
    Highlight.FillColor = FillColor
    Highlight.DepthMode = DepthMode
    Highlight.FillTransparency = FillTransparency
    Highlight.OutlineColor = OutlineColor
    Highlight.OutlineTransparency = 0
    Highlight.Parent = Storage
    
    local plrchar = plr.Character
    if plrchar then
        Highlight.Adornee = plrchar
    end

    connections[plr] = plr.CharacterAdded:Connect(function(char)
        Highlight.Adornee = char
    end)
end

Players.PlayerAdded:Connect(Highlight)
for i,v in next, Players:GetPlayers() do
    Highlight(v)
end

Players.PlayerRemoving:Connect(function(plr)
    local plrname = plr.Name
    if Storage[plrname] then
        Storage[plrname]:Destroy()
    end
    if connections[plr] then
        connections[plr]:Disconnect()
    end
end)
   end,
})

local ExploitsTab = Window:CreateTab("Exploits", "crown")
local Section = ExploitsTab:CreateSection("Exploits")

local Button = ExploitsTab:CreateButton({
   Name = "Elysian Exploits",
   Callback = function()
   getgenv().Elysian = {
    ['Camlock'] = {
        ['Manual Prediction'] = 0.1475,
        ['Auto Prediction'] = {
            ['Enabled'] = true,
            ['Ping'] = {
                ['20'] = 0.10036,
                ['30'] = 0.1130,
                ['40'] = 0.13544,
                ['50'] = 0.1357,
                ['60'] = 0.13598,
                ['70'] = 0.13892,
                ['80'] = 0.1403,
                ['90'] = 0.1446,
                ['100'] = 0.1475
            }
        },
        ['Smoothing'] = {
            ['Enabled'] = false,
            ['Value'] = 0.013
        },
        ['Offset'] = {
            ['Jump'] = -1,
            ['Fall'] = -1,
        },
        ['Auto Shoot'] = true,
        ['Airshot Function'] = {
            ['Enabled'] = true,
            ['Part'] = "LowerTorso"
        },
        ['Target Part'] = "HumanoidRootPart"
    },
    ['HvH'] = {
        ['Target Strafe'] = {
            ['Enabled'] = true,
            ['Speed'] = 100,
            ['Distance'] = 8,
            ['Height'] = 8,
        },
        ['Cframe Walk'] = {
            ['Enabled'] = true,
            ['Amount'] = 4
        }
    }
}

local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local client = players.LocalPlayer
local camera = workspace.CurrentCamera
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")

local Locking = false
local Plr = nil
local strafing = false
local cframing = false
local auto_shooting = false

local playerData = {}
local SMOOTHNESS_FACTOR = 2

local function GetEvent()
    for _, v in pairs(game.ReplicatedStorage:GetChildren()) do
        if v.Name == "MainEvent" or v.Name == "Bullets" or v.Name == ".gg/untitledhood" or v.Name == "Remote" or v.Name == "MAINEVENT" or v.Name == ".gg/flamehood" then
            return v
        end
    end
end

local function GetArgs()
    local PlaceId = game.PlaceId
    if PlaceId == 2788229376 or PlaceId == 4106313503 or PlaceId == 11143225577 or PlaceId == 17319408836 or PlaceId == 18110728826 then
        return "UpdateMousePosI"
    elseif PlaceId == 5602055394 or PlaceId == 7951883376 then
        return "MousePos"
    elseif PlaceId == 10100958808 or PlaceId == 12645617354 or PlaceId == 14171242539 or PlaceId == 14412436145 or PlaceId == 14412355918 or PlaceId == 14413720089 or PlaceId == 17403265390 or PlaceId == 17403166075 or PlaceId == 17403262882 or PlaceId == 15186202290 or PlaceId == 15763494605 then
        return "MOUSE"
    elseif PlaceId == 9825515356 then
        return "MousePosUpdate"
    elseif PlaceId == 15166543806 then
        return "MoonUpdateMousePos"
    elseif PlaceId == 16033173781 or PlaceId == 7213786345 then
        return "UpdateMousePosI"
    else
        return "UpdateMousePos"
    end
end

local mainEvent = GetEvent()

function GetClosestToCenter()
    local closestDist = math.huge
    local closestPlr = nil
    local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    
    for _, v in ipairs(players:GetPlayers()) do
        if v ~= client and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
            local screenPos, onScreen = camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
            if onScreen then
                local distToCenter = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
                if distToCenter < closestDist then
                    closestPlr = v
                    closestDist = distToCenter
                end
            end
        end
    end
    return closestPlr
end

local function getPart()
    if not Plr or not Plr.Character then
        return nil
    end

    local humanoid = Plr.Character:FindFirstChild("Humanoid")
    if not humanoid then
        return nil
    end

    if humanoid:GetState() == Enum.HumanoidStateType.Freefall and getgenv().Elysian['Camlock']['Airshot Function']['Enabled'] then
        local airshotPart = Plr.Character:FindFirstChild(getgenv().Elysian['Camlock']['Airshot Function']['Part'])
        if airshotPart then
            return airshotPart
        end
    end

    local targetPart = Plr.Character:FindFirstChild(getgenv().Elysian['Camlock']['Target Part'])
    if targetPart then
        return targetPart
    end

    return Plr.Character:FindFirstChild("HumanoidRootPart")
end

local function getPredictionValue()
    if getgenv().Elysian['Camlock']['Auto Prediction']['Enabled'] then
        local ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
        local pingTable = getgenv().Elysian['Camlock']['Auto Prediction']['Ping']
        
        for i = ping, 0, -1 do
            if pingTable[tostring(i)] then
                return pingTable[tostring(i)]
            end
        end
        
        return pingTable['100']
    else
        return getgenv().Elysian['Camlock']['Manual Prediction']
    end
end

local function calculatePosition(victim, velocity)
    local prediction = getPredictionValue()
    local jumpOffset = getgenv().Elysian['Camlock']['Offset']['Jump']
    local fallOffset = getgenv().Elysian['Camlock']['Offset']['Fall']
    
    local playerData = playerData[victim.Parent.Parent]
    if not playerData then
        playerData = {
            SmoothedVelocity = velocity
        }
        playerData[victim.Parent.Parent] = playerData
    end
    
    playerData.SmoothedVelocity = playerData.SmoothedVelocity:Lerp(velocity, 0.5)
    
    local pos = victim.Position + playerData.SmoothedVelocity * prediction

    if victim.Parent and victim.Parent:FindFirstChild("Humanoid") then
        local humanoid = victim.Parent.Humanoid
        if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            pos = pos + Vector3.new(0, jumpOffset, 0)
        elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            pos = pos + Vector3.new(0, fallOffset, 0)
        end
    end

    return pos
end

local function CharAdded()
    if Locking and Plr and Plr.Character and playerData[Plr] then
        local Part = getPart()
        if Part then
            local Position = calculatePosition(Part, playerData[Plr].Velocity)
            mainEvent:FireServer(GetArgs(), Position)
        end
    end
end

client.Character.ChildAdded:Connect(function(child)
    if child:IsA("Tool") then
        child.Activated:Connect(CharAdded)
    end
end)

client.CharacterAdded:Connect(function(character)
    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            child.Activated:Connect(CharAdded)
        end
    end)
end)

local function Process(player, dT)
    if not player or not player.Character then
        return
    end

    local PrimaryPart = player.Character:FindFirstChild("HumanoidRootPart")
    if not PrimaryPart then
        return
    end

    if not playerData[player] then
        playerData[player] = {
            PreviousPosition = PrimaryPart.Position,
            Velocity = Vector3.new(0, 0, 0),
            OnScreen = false,
            ScreenPosition = Vector2.new(0, 0)
        }
    end

    local CurrentPosition = PrimaryPart.Position
    local PreviousPosition = playerData[player].PreviousPosition
    local Displacement = CurrentPosition - PreviousPosition

    local targetVelocity = Displacement / dT
    playerData[player].Velocity = playerData[player].Velocity:Lerp(targetVelocity, 0.5)
    playerData[player].PreviousPosition = CurrentPosition
    
    local ScreenPosition, OnScreen = workspace.CurrentCamera:WorldToViewportPoint(CurrentPosition)

    playerData[player].OnScreen = OnScreen
    playerData[player].ScreenPosition = Vector2.new(ScreenPosition.X, ScreenPosition.Y)
end

local strafeAngle = 0

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = CoreGui
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local function SavePositions(positions)
    local json = HttpService:JSONEncode(positions)
    writefile("button_positions.json", json)
end

local function LoadPositions()
    if isfile("button_positions.json") then
        local json = readfile("button_positions.json")
        return HttpService:JSONDecode(json)
    end
    return {}
end

local savedPositions = LoadPositions()

local function CreateButton(name, defaultPosition, callback)
    local Button = Instance.new("TextButton")
    Button.Size = UDim2.new(0, 100, 0, 50)
    Button.Position = savedPositions[name] and UDim2.new(0, savedPositions[name].X, 0, savedPositions[name].Y) or defaultPosition
    Button.Text = name
    Button.Parent = ScreenGui
    Button.BackgroundColor3 = Color3.fromRGB(246, 198, 208)
    Button.BorderSizePixel = 0
    Button.Font = Enum.Font.Code
    Button.TextColor3 = Color3.new(0, 0, 0)
    Button.TextSize = 16
    Button.AutoButtonColor = false

    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 8)
    Corner.Parent = Button

    local Shadow = Instance.new("Frame")
    Shadow.Size = UDim2.new(1, 6, 1, 6)
    Shadow.Position = UDim2.new(0, -3, 0, -3)
    Shadow.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    Shadow.BackgroundTransparency = 0.7
    Shadow.ZIndex = -1
    Shadow.Parent = Button

    local ShadowCorner = Instance.new("UICorner")
    ShadowCorner.CornerRadius = UDim.new(0, 8)
    ShadowCorner.Parent = Shadow

    local isActive = false

    local function updateButtonState()
        local targetColor = isActive and Color3.fromRGB(135, 206, 235) or Color3.fromRGB(246, 198, 208)
        local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = game:GetService("TweenService"):Create(Shadow, tweenInfo, {BackgroundColor3 = targetColor})
        tween:Play()
    end

    Button.MouseButton1Click:Connect(function()
        isActive = not isActive
        updateButtonState()
        callback(isActive)
    end)

    local dragStart, startPos

    Button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragStart = input.Position
            startPos = Button.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragStart = nil
                    savedPositions[name] = {X = Button.Position.X.Offset, Y = Button.Position.Y.Offset}
                    SavePositions(savedPositions)
                end
            end)
        end
    end)

    Button.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement then
            if dragStart then
                local delta = input.Position - dragStart
                Button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end
    end)
    
    return Button, function() return isActive end
end

local CamlockButton, getCamlockState = CreateButton("Camlock", UDim2.new(0, 10, 0, 10), function(state)
    Locking = state
    if Locking then
        Plr = GetClosestToCenter()
    else
        Plr = nil
    end
end)

if getgenv().Elysian['HvH']['Target Strafe']['Enabled'] then
    local StrafeButton, getStrafeState = CreateButton("Strafe", UDim2.new(0, 10, 0, 70), function(state)
        strafing = state
    end)
end

if getgenv().Elysian['HvH']['Cframe Walk']['Enabled'] then
    local CframeButton, getCframeState = CreateButton("Cframe", UDim2.new(0, 10, 0, 130), function(state)
        cframing = state
    end)
end

if getgenv().Elysian['Camlock']['Auto Shoot'] then
    local AutoShootButton, getAutoShootState = CreateButton("AutoShoot", UDim2.new(0, 10, 0, 190), function(state)
        auto_shooting = state
    end)
end

local function AutoShoot()
    if Locking and Plr then
        local character = client.Character
        if character then
            local tool = character:FindFirstChildOfClass("Tool")
            if tool and tool:IsA("Tool") then
                tool:Activate()
            end
        end
    end
end

runService.Heartbeat:Connect(function(dT)
    for _, player in ipairs(players:GetPlayers()) do
        if player ~= client then
            Process(player, dT)
        end
    end

    if getgenv().Elysian['HvH']['Target Strafe']['Enabled'] and Locking and strafing and Plr and Plr.Character then
        local targetHRP = Plr.Character:FindFirstChild("HumanoidRootPart")
        if targetHRP then
            strafeAngle = strafeAngle + math.rad(getgenv().Elysian['HvH']['Target Strafe']['Speed'])
            
            local distance = getgenv().Elysian['HvH']['Target Strafe']['Distance']
            local height = getgenv().Elysian['HvH']['Target Strafe']['Height']
            
            local offsetX = math.sin(strafeAngle) * distance
            local offsetZ = math.cos(strafeAngle) * distance
            local offsetY = math.sin(strafeAngle * 2) * height
            
            local predictedPosition = calculatePosition(targetHRP, playerData[Plr].Velocity)
            local strafePosition = predictedPosition + Vector3.new(offsetX, offsetY, offsetZ)
            
            if client.Character and client.Character:FindFirstChild("HumanoidRootPart") then
                client.Character.HumanoidRootPart.CFrame = CFrame.new(strafePosition, predictedPosition)
            end
        end
    end

    if cframing and getgenv().Elysian['HvH']['Cframe Walk']['Enabled'] and client.Character and client.Character:FindFirstChild("Humanoid") and client.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = client.Character.HumanoidRootPart
        local moveDirection = client.Character.Humanoid.MoveDirection
        hrp.CFrame = hrp.CFrame + (moveDirection * getgenv().Elysian['HvH']['Cframe Walk']['Amount'])
    end

    if auto_shooting then
        AutoShoot()
    end
end)

runService.RenderStepped:Connect(function()
    if Locking and Plr and Plr.Character and playerData[Plr] then
        local Part = getPart()
        if Part then
            local Position = calculatePosition(Part, playerData[Plr].Velocity)
            local Main = CFrame.new(camera.CFrame.p, Position)
            
            if getgenv().Elysian['Camlock']['Smoothing']['Enabled'] then
                camera.CFrame = camera.CFrame:Lerp(Main, getgenv().Elysian['Camlock']['Smoothing']['Value'])
            else
                camera.CFrame = Main
            end
        end
    end
end)
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "BallWare (Da strike)",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/DHBCommunity/DHBOfficialScript/refs/heads/main/Protected_4021809531880627.txt"))()
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "BallWare (Works in some games)",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/DHBCommunity/DHBOfficialScript/main/FinallyV4"))()
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "Bates AutoShoot",
   

local Button = ExploitsTab:CreateButton({
   Name = "NetWork Desync (Needs X Keybind)",
   Callback = function()
   local Key = "X"
local Enabled = false
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Client = Players.LocalPlayer

local MainThread = task.spawn(function()
    while true do
        if Enabled and Client.Character and Client.Character:FindFirstChild("HumanoidRootPart") then
            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", true)
            task.wait()
            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
        end

        task.wait()
    end
end)

UserInputService.InputBegan:Connect(function(Input)
    if UserInputService:GetFocusedTextBox() then
        return
    end

    if Input.KeyCode.Name == Key then
        Enabled = not Enabled

        if Enabled then
            setfflag("S2PhysicsSenderRate", 2)
        else
            setfflag("S2PhysicsSenderRate", 13)
            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
        end
    end
end)
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "Xora TP Walk",
   Callback = function()
   loadstring(Game:HttpGet("https://raw.githubusercontent.com/TheRealXORA/Roblox/refs/heads/Main/Scripts%20/Universal%20/Tpwalk.lua", true))()
   end,
})
