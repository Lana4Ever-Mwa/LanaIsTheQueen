 local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Mobile Supported GUI",
   LoadingTitle = "GUI For Mobile Players",
   LoadingSubtitle = "By JJ",
   Theme = "Bloom", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   DisableRayfieldPrompts = true,
   DisableBuildWarnings = true, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Mobile Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local MainTab = Window:CreateTab("Main", "sparkles")
local MainSection = MainTab:CreateSection("Main")

local Paragraph = MainTab:CreateParagraph({Title = "Scripts Warning:", Content = "Some scripts may cause a permanent ban on Da Hood games...SO BEWARE!"})
local Divider = MainTab:CreateDivider()

   local Dropdown = MainTab:CreateDropdown({
   Name = "Themes",
   Options = {"Bloom","Serenity","Amethyst","Ocean","AmberGlow","DarkBlue","Green","Light","Default"},
   CurrentOption = {"Bloom"},
   MultipleOptions = false,
   Flag = "Dropdown1",
   Callback = function(Options)
   Window.ModifyTheme(Options[1])
   end,
})

local Divider = MainTab:CreateDivider()

local LocksTab = Window:CreateTab("Locks", "lock-keyhole")
local LocksSection = LocksTab:CreateSection("Locks")

    Rayfield:Notify({
   Title = "You've exucuted the GUI!",
   Content = "Enjoy!",
   Duration = 3,
   Image = "heart",
})

local Button = LocksTab:CreateButton({
   Name = "Advanced Silent Aim",
   Callback = function()
   getgenv().khen = {
    ['Silent'] = {
        Normal = {
            Enabled = true,
            HitPart = "HumanoidRootPart",
            Prediction = 0.1657724,
            AirPrediction = 0.149,
        },
        FOV = {
            FOVSize = 130,
            ShowFOV = true,
        },
        Resolver = {
            Enabled = true,
        }
    },
}

loadstring(game:HttpGet("https://raw.githubusercontent.com/khenn791/script-khen/refs/heads/main/SilentAim", true))();
   end,
})

local Button = LocksTab:CreateButton({
   Name = "Vascal Silent Aim",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/Gwaporoblox/VascalSilentaim/main/README.md"))()
   end,
})

local Button = LocksTab:CreateButton({
   Name = "Vascal CamLock",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/Stomp-Shop-Da-Strike-PSXbox-Vascal-Lock-14629"))()
   end,
})

local Button = LocksTab:CreateButton({
   Name = "BaldsLock",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/sdfesdfsedf/srgtergasdfs/main/wwwwwww", true))()
   end,
})

local Button = LocksTab:CreateButton({
   Name = "Ace CamLock",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/Totocoems/Ace/main/Ace"))()
   end,
})

local Button = LocksTab:CreateButton({
   Name = "Carlcc CamLock",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/28asjdjasdkj/adsadasdw234dasd/refs/heads/main/GODISGREAT"))()
   end,
})

local AntiLockTab = Window:CreateTab("AntiLock", "shield-alert")
local Section = AntiLockTab:CreateSection("AntiLocks")

local Button = AntiLockTab:CreateButton({
   Name = "Kirbsware AntiLock",
   Callback = function()
   loadstring(game:HttpGet('https://raw.githubusercontent.com/wenny69420/KirbswareScripts/main/MobileV3'))()
   end,
})

local FlyScriptsTab = Window:CreateTab("FlyScripts", "plane")
local Section = FlyScriptsTab:CreateSection("FlyScripts")

local Button = FlyScriptsTab:CreateButton({
   Name = "Flying Script IOS",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/scripthubekitten/dahoodios/main/hoodcustomfly", true))()
   end,
})

local Button = FlyScriptsTab:CreateButton({
   Name = "Flying Script",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-Fly-script-v3-16742"))()
   end,
})

local Button = FlyScriptsTab:CreateButton({
   Name = "Xora Flying Script",
   Callback = function()
   -- Fly [ NEW! ]
loadstring(Game:HttpGet("https://raw.githubusercontent.com/TheRealXORA/Roblox/refs/heads/Main/Scripts%20/Universal%20/Fly.lua", true))()
   end,
})

local UseFulTab = Window:CreateTab("UseFul", "infinity")
local Section = UseFulTab:CreateSection("UseFul Things")

local Button = UseFulTab:CreateButton({
   Name = "RightClick",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/DHBCommunity/DHBOfficialScript/main/RightClick"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Chat Spammer",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/IncognitoChat-Hangout-or-UNIVERSAL-V2-17194"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Chat Bypass",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/shadow62x/catbypass/main/upfix"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Mobile Macro #1",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/DHBCommunity/DHBOfficialScript/main/macromobbyballigusapo"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Mobile Macro #2",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/DHBCommunity/DHBOfficialScript/main/MacroBalli"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Mobile Macro #3",
   Callback = function()
   getgenv().Depart = {
    ["Aimbot"] = {
        ["Enabled"] = false,
        ["Notifications"] = false,
        ["PINGBASED"] = false,
        ["PredictionValue"] = 0.129,
        ["Radius"] = 150,
        ["AirPrediction"] = 0.14633
    },
    ["AimbotCamlock"] = {
        ["Smoothness"] = 0,
        ["AirSmoothness"] = 0.217,
        ["Campred"] = 0.449,
        ["ShakeValue"] = 0,
        ["AimPart"] = "HumanoidRootPart"
    },
    ["FOVSettings"] = {
        ["FOVVisible"] = false,
        ["FOVSize"] = 150
    },
    ["Checks"] = {
        ["FriendCheck"] = false,
        ["UnlockOnKO"] = true,
        ["AntiGroundShots"] = true
    },
    ["Visuals"] = {
        ["Line"] = false,
        ["Highlight"] = false,
        ["Emoji"] = false,
        ["EmojiType"] = "🥵"
    },
    ["BulletRedirection"] = { 
        ["Enabled"] = false,
        ["HitPart"] = "HumanoidRootPart",
        ["AirPart"] = "Head",
        ["Prediction"] = 0.14633,
        ["AirPrediction"] = 0.129,
        ["FOV"] = {
            ["Visible"] = false,
            ["Size"] = 150
        },
        ["Checks"] = {
            ["WallCheck"] = true,
            ["FriendCheck"] = false,
            ["KOCheck"] = true,
            ["AntiGroundShots"] = true
        },
        ["Hitchance"] = {
            ["Value"] = 100
        }
    },
    ["Triggerbot"] = {
        ["Enabled"] = false,
        ["Delay"] = 0,
        ["TapDelay"] = 0.01,
        ["UsePrediction"] = true,
        ["Prediction"] = 0.125,
        ["Tolerance"] = 15,
        ["Distance"] = 300,
        ["FOVSize"] = 150,
        ["FOVShow"] = false,
        ["Whitelisted"] = {"[Double-Barrel SG]", "[DoubleBarrel]", "[Revolver]", "[TacticalShotgun]"},
        ["UseWhitelist"] = true, 
        ["AimParts"] = {"HumanoidRootPart", "Head"},
        ["WallCheck"] = true,
        ["KOCheck"] = true
    },
    ["Utility"] = {
        ["Tool"] = false,
        ["Button"] = true,
        ["ButtonSize"] = 10,
        ["Macro"] = true
    }
}

-- credits to chatgpt tapn with the method
--dont laugh at how gen it is i just used teh method

wait(0.5)
getgenv().Depart = getgenv().Depart
local plr = game:GetService("Players").LocalPlayer



local cclosure = syn_newcclosure or newcclosure or nil



if not cclosure or not hookmetamethod then

   plr:Kick("\n\nYour exploit doesn't support hookmetamethod\n")

end



local oldNamecall

oldNamecall = hookmetamethod(game, "__namecall", cclosure(function(self,...)

   local NamecallMethod = getnamecallmethod()

   local args = {...}

   

   if (NamecallMethod == "Kick" or NamecallMethod == "kick") and not checkcaller() then

       if self ~= plr then

           return oldNamecall(self,...)

       end

       return

   end

   

   return oldNamecall(self,...)

end))
        local function playIntro()
            local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")

            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = "IntroScreen"
            screenGui.Parent = playerGui

            local frame = Instance.new("Frame")
            frame.Name = "IntroFrame"
            frame.Parent = screenGui
            frame.Size = UDim2.new(1, 0, 1, 0)
            frame.BackgroundTransparency = 1

            local imageLabel = Instance.new("ImageLabel")
            imageLabel.Name = "Living Legend"
            imageLabel.Parent = frame
            imageLabel.Size = UDim2.new(0.4, 0, 0.4, 0)
            imageLabel.Position = UDim2.new(0.3, 0, 0.3, 0)
            imageLabel.Image = "rbxassetid://83310144482533"
            imageLabel.BackgroundTransparency = 1
            imageLabel.ImageTransparency = 1

            local sound = Instance.new("Sound")
            sound.Name = "IntroSound"
            sound.Parent = frame
            sound.SoundId = "rbxassetid://14843357644"
            sound.Volume = 15
            sound:Play()

            local tweenService = game:GetService("TweenService")

            local blurEffect = Instance.new("BlurEffect")
            blurEffect.Parent = game.Lighting
            blurEffect.Size = 10

            local tweenInfo = TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

            local fadeIn = tweenService:Create(imageLabel, tweenInfo, {ImageTransparency = 0.5})
            local fadeOut = tweenService:Create(imageLabel, tweenInfo, {ImageTransparency = 1})
            local blurTween = tweenService:Create(blurEffect, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = 0})

            fadeIn:Play()
            fadeIn.Completed:Wait()

            wait(2)

            fadeOut:Play()
            fadeOut.Completed:Wait()

            blurTween:Play()
            blurTween.Completed:Wait()

            blurEffect:Destroy()
            screenGui:Destroy()
        end

        playIntro()
        
wait(0.5)
print("Loaded!")
if Depart.Aimbot.Enabled then
local CC = game:GetService("Workspace").CurrentCamera
local player = game.Players.LocalPlayer
local mouse = player:GetMouse()
local placemarker = Instance.new("Part", game.Workspace)
placemarker.Anchored = true
placemarker.CanCollide = false
placemarker.Size = Vector3.new(6, 6, 6)
placemarker.Transparency = 1

local AimlockState = false
local Victim = nil
local Plr
local function shouldLockOntoPlayer(targetPlayer)
    -- If FriendCheck is enabled and the target is a friend, do not lock onto the player
    if Depart.Checks.FriendCheck then
        -- If FriendCheck is enabled and the target is a friend, return false to avoid locking onto friends
        if isFriend(targetPlayer) then
            return false
        end
    end
    -- If FriendCheck is disabled, allow locking onto friends
    return true
end


local function Notify(text)
    game.StarterGui:SetCore("SendNotification", {
        Title = "Notification",
        Text = text,
        Duration = 2,
    })
end

local highlightInstance  -- Variable to hold the highlight instancegg

local function highlightPlayer(targetPlayer)
    if targetPlayer.Character then
        local highlight = Instance.new("Highlight")
        highlight.Parent = targetPlayer.Character
        highlight.FillColor = Color3.fromRGB(127, 0, 255)  -- Set the highlight color
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)  -- Set the outline color
        highlight.FillTransparency = 0.5  -- Set the transparency
        highlight.OutlineTransparency = 0.5  -- Set the outline transparency
        return highlight
    end
end




local function lockOntoPlayer(player)
    Plr = player
    AimlockState = true
    if Depart.Aimbot.Notifications then
        Notify("Locked On: " .. tostring(Plr.Name))
    end

    -- Apply highlight if Visuals.Highlight is enabled
    if Depart.Visuals.Highlight and player.Character then
        highlightInstance = highlightPlayer(player)  -- Call the highlight function
    end

    -- Create and show emoji if Emoji is enabled
    if Depart.Visuals.Emoji then
        if not emojiLabel then
            createEmoji()  -- Create emoji if it doesn't exist
        end
    end
end

local function unlockPlayer()
    AimlockState = false
    Plr = nil
    
    if Depart.Aimbot.Notifications then
        Notify("Unlocked")
    end
end

if Depart.Aimbot.PINGBASED then
    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
    ping = tonumber(string.split(ping, '(')[1]) or 0 -- Safe parse
    
    if ping < 10 then
        Depart.Aimbot.PredictionValue = 0.10087127181718181 -- For pings below 10ms
    elseif ping < 20 then
        Depart.Aimbot.PredictionValue = 0.10087127181718181 -- Same as original for 10-20ms range
    elseif ping < 30 then
        Depart.Aimbot.PredictionValue = 0.11027333333333333 -- Updated for 20-30ms
    elseif ping < 40 then
        Depart.Aimbot.PredictionValue = 0.11561500000000001 -- Updated for 30-40ms
    elseif ping < 50 then
        Depart.Aimbot.PredictionValue = 0.12109333333333334 -- Updated for 40-50ms
    elseif ping < 60 then
        Depart.Aimbot.PredictionValue = 0.12670833333333334 -- Updated for 50-60ms
    elseif ping < 70 then
        Depart.Aimbot.PredictionValue = 0.13246 -- Updated for 60-70ms
    elseif ping < 80 then
        Depart.Aimbot.PredictionValue = 0.13834833333333335 -- Updated for 70-80ms
    elseif ping < 90 then
        Depart.Aimbot.PredictionValue = 0.14437333333333335 -- Updated for 80-90ms
    elseif ping < 100 then
        Depart.Aimbot.PredictionValue = 0.15053500000000003 -- Updated for 90-100ms
    elseif ping < 110 then
        Depart.Aimbot.PredictionValue = 0.15683333333333335 -- Updated for 100-110ms
    elseif ping < 120 then
        Depart.Aimbot.PredictionValue = 0.16326833333333332 -- Updated for 110-120ms
    elseif ping < 130 then
        Depart.Aimbot.PredictionValue = 0.16984 -- Updated for 120-130ms
    elseif ping < 140 then
        Depart.Aimbot.PredictionValue = 0.17654833333333333 -- Updated for 130-140ms
    elseif ping < 150 then
        Depart.Aimbot.PredictionValue = 0.18339333333333335 -- Updated for 140-150ms
    elseif ping < 160 then
        Depart.Aimbot.PredictionValue = 0.190375 -- Updated for 150-160ms
    elseif ping < 170 then
        Depart.Aimbot.PredictionValue = 0.19749333333333333 -- Updated for 160-170ms
    elseif ping < 180 then
        Depart.Aimbot.PredictionValue = 0.20474833333333334 -- Updated for 170-180ms
    elseif ping < 190 then
        Depart.Aimbot.PredictionValue = 0.21214 -- Updated for 180-190ms
    elseif ping < 200 then
        Depart.Aimbot.PredictionValue = 0.21966833333333335 -- Updated for 190-200ms
    else
        Depart.Aimbot.PredictionValue = 0.22733333333333333 -- For pings above 200ms
    end
end




local function isFriend(player)
    return player:IsFriendsWith(game.Players.LocalPlayer.UserId)
end
local function unlockIfKOedOrFriend(victim)
    local koCheck = victim.Character:FindFirstChild("BodyEffects") and victim.Character.BodyEffects:FindFirstChild("K.O")
    local grabbedCheck = victim.Character:FindFirstChild("GRABBING_CONSTRAINT")
    
    -- Check if the target is K.O. or grabbed, and also utilize the shouldLockOntoPlayer check
    if (koCheck and koCheck.Value) or grabbedCheck or not shouldLockOntoPlayer(victim) then
        AimlockState = false
        Victim = nil
    end
end



game:GetService("RunService").Heartbeat:Connect(function()
    if AimlockState and Victim then
        unlockIfKOedOrFriend(Victim)
    end
end)





local function getClosestPlayerInFOV()
    local closestPlayer = nil
    local shortestDistance = Depart.FOVSettings.FOVSize
    local screenCenter = Vector2.new(CC.ViewportSize.X / 2, CC.ViewportSize.Y / 2)
    local playerPosition = player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.Position

    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("Humanoid") and otherPlayer.Character.Humanoid.Health > 0 then
            -- Check if the player should be locked onto, considering FriendCheck
            if shouldLockOntoPlayer(otherPlayer) then
                local humanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    local distance = (humanoidRootPart.Position - playerPosition).magnitude
                    if distance <= Depart.Aimbot.Radius then
                        local pos = CC:WorldToViewportPoint(humanoidRootPart.Position)
                        local fovPos = Vector2.new(pos.X, pos.Y)
                        local magnitude = (fovPos - screenCenter).magnitude
                        
                        if magnitude < Depart.FOVSettings.FOVSize and magnitude < shortestDistance then
                            closestPlayer = otherPlayer
                            shortestDistance = magnitude
                        end
                    end
                end
            end
        end
    end
    return closestPlayer
end


-- Create the Drawing line
local line = Drawing.new("Line")
line.Thickness = 2 -- Set the thickness of the line
line.Color = Color3.fromRGB(127, 0, 255) -- Set the color of the line (e.g., red)
line.Visible = false -- Initially not visible
line.Transparency = 1 -- Fully transparent initially




local emojiLabel -- Declare the emoji label variable

local function isTargetInAir(character)
    return character.Humanoid.FloorMaterial == Enum.Material.Air
end

local function updateAimlockAndMarker()
    if AimlockState and Victim and Victim.Character then
        local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            local aimPart = Depart.AimbotCamlock.AimPart
            local target = Victim.Character[aimPart]

            -- AntiGroundShots logic
            if Depart.Checks.AntiGroundShots and Victim.Character then
                local targetBone = Victim.Character:FindFirstChild(aimPart)
                if targetBone and targetBone.Velocity.Y < 0 then
                    targetBone.Velocity = Vector3.new(targetBone.Velocity.X, 0, targetBone.Velocity.Z)
                    targetBone.AssemblyLinearVelocity = Vector3.new(targetBone.Velocity.X, 0, targetBone.Velocity.Z)
                end
            end

            if target then
                -- Calculate the target's predicted position
                local targetVelocity = Victim.Character[aimPart].Velocity
                local predictedPosition = target.Position + (targetVelocity * Depart.Aimbot.PredictionValue)

                -- Use isTargetInAir to adjust prediction when the target is jumping
                if isTargetInAir(Victim.Character) then
                    predictedPosition = predictedPosition + (targetVelocity * Depart.Aimbot.AirPrediction)
                end

                local LookPosition = CFrame.new(CC.CFrame.p, predictedPosition)
                CC.CFrame = CC.CFrame:Lerp(LookPosition, Depart.AimbotCamlock.Smoothness)
                placemarker.CFrame = CFrame.new(Victim.Character.HumanoidRootPart.Position)

                -- Update emoji position if enabled
                if Depart.Visuals.Emoji then
                    if not emojiLabel then
                        emojiLabel = Drawing.new("Text")
                        emojiLabel.Text = Depart.Visuals.EmojiType
                        emojiLabel.Size = 30
                        emojiLabel.Color = Color3.fromRGB(135, 206, 235)
                    end
                    local targetScreenPos = CC:WorldToViewportPoint(predictedPosition)
                    emojiLabel.Position = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
                    emojiLabel.Visible = true
                end

                -- Calculate the 2D positions for the line drawing
                local targetScreenPos = CC:WorldToViewportPoint(Victim.Character.HumanoidRootPart.Position)
                local predictedScreenPos = CC:WorldToViewportPoint(predictedPosition)

                if Depart.Visuals.Line then
                    line.From = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
                    line.To = Vector2.new(predictedScreenPos.X, predictedScreenPos.Y)
                    line.Visible = true
                end
            end
        end
    else
        placemarker.CFrame = CFrame.new(0, 9999, 0)
        line.Visible = true

        if emojiLabel then
            emojiLabel.Visible = true
            emojiLabel:Destroy()
            emojiLabel = nil
        end
        if highlightInstance then
            highlightInstance:Destroy()
            highlightInstance = nil
        end
    end
end


game:GetService("RunService").RenderStepped:Connect(function()
    updateAimlockAndMarker()
end)

-- Create a Screen GUI for toggle button only if Button is enabled
if Depart.Utility.Button then
    local screenGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
    screenGui.ResetOnSpawn = false

    local toggleButton = Instance.new("ImageButton")
    toggleButton.Parent = screenGui
    local buttonSize = Depart.Utility.ButtonSize
    toggleButton.Size = UDim2.new(0, buttonSize, 0, buttonSize) -- Set both width and height to the same value
    toggleButton.Position = UDim2.new(0.5, -buttonSize / 2, 0.8, -buttonSize / 2) -- Center the button
    toggleButton.Image = "rbxassetid://18261026237" -- Replace with the actual image asset ID
    toggleButton.BackgroundTransparency = 1 -- Set to 1 for a transparent background


    local function toggleAimlock()
        if Depart.Aimbot.Enabled then
            AimlockState = not AimlockState
            if AimlockState then
                Victim = getClosestPlayerInFOV()
                if Victim then
                    lockOntoPlayer(Victim)
                else
                    unlockPlayer()
                end
            else
                unlockPlayer()
            end
        end
    end

    toggleButton.MouseButton1Click:Connect(toggleAimlock)

    -- Mobile Draggable Functionality
    local dragging, dragStart, startPos = true, nil, nil
    toggleButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = toggleButton.Position
        end
    end)

    toggleButton.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
            local delta = input.Position - dragStart
            toggleButton.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    toggleButton.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
        end
    end)
end
local tool
if Depart.Utility.Tool then
    tool = Instance.new("Tool")
    tool.Name = "LockTool"
    tool.RequiresHandle = false
    tool.Parent = player.Backpack
tool.Activated:Connect(function()
    if Depart.Aimbot.Enabled then
        AimlockState = not AimlockState
        if AimlockState then
            Victim = getClosestPlayerInFOV()
            if Victim then
                lockOntoPlayer(Victim)
            else
                unlockPlayer()
            end
        else
            unlockPlayer()
        end
    end
end)
end

spawn(function()
    placemarker.Anchored = true
    placemarker.CanCollide = false
    placemarker.Size = Vector3.new(6, 6, 6)
    placemarker.Transparency = 1
end)

-- Patch to prevent FPS drop
local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)
mt.__namecall = newcclosure(function(...)
    local args = {...}
    if AimlockState and getnamecallmethod() == "FireServer" then
        if args[2] == "UpdateMousePos" or args[2] == "MOUSE" or args[2] == "UpdateMousePosI2" or args[2] == "MousePosUpdate" then
            if Depart.Aimbot.Enabled and Plr and Plr.Character then
                args[3] = Plr.Character[Depart.AimbotCamlock.AimPart].Position + (Plr.Character[Depart.AimbotCamlock.AimPart].Velocity * Depart.Aimbot.PredictionValue) -- Prediction based on position
                return old(unpack(args))
            end
        end
    end
    return old(...)
end)

-- Clean-up on character removal
player.CharacterRemoving:Connect(function()
    if tool then
        tool.Parent = player.Backpack
    end
end)
end
if Depart.BulletRedirection.Enabled then
-- Define SafePlayers directly in the script
local SafePlayers = {
    "NO_HUSTLE", --
    "atomicccuser433",
}

-- Existing global variables for Bullet Redirection
getgenv().HitPart = getgenv().Depart["BulletRedirection"].HitPart
getgenv().AirPart = getgenv().Depart["BulletRedirection"].AirPart
getgenv().Prediction_BulletRedirection = getgenv().Depart["BulletRedirection"].Prediction
getgenv().AirPrediction_BulletRedirection = getgenv().Depart["BulletRedirection"].AirPrediction
getgenv().BulletRedirectionEnabled = getgenv().Depart["BulletRedirection"].Enabled
getgenv().BulletRedirectionShowFOV = getgenv().Depart["BulletRedirection"].FOV.Visible
getgenv().BulletRedirectionFOVSize = getgenv().Depart["BulletRedirection"].FOV.Size
getgenv().BulletRedirectionHitchance = getgenv().Depart["BulletRedirection"].Hitchance.Value / 100 -- Convert to a fraction

-- Create FOV Drawing for Bullet Redirection
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = getgenv().BulletRedirectionShowFOV
FOVCircle.Thickness = 2
FOVCircle.Color = Color3.fromRGB(246, 198, 208) -- Set stroke color to green
FOVCircle.NumSides = 100
FOVCircle.Radius = getgenv().BulletRedirectionFOVSize
FOVCircle.Position = Vector2.new(0, 0) -- Will be updated later
FOVCircle.Filled = false

-- Function to update FOV Drawing Position and Visibility
local function updateFOVCircle()
    if getgenv().BulletRedirectionShowFOV then
        FOVCircle.Visible = true
        FOVCircle.Radius = getgenv().BulletRedirectionFOVSize
        local centerScreenPosition = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
        FOVCircle.Position = centerScreenPosition -- Center it
    else
        FOVCircle.Visible = false
    end
end

-- Optimize to run FOV update less frequently
local FOVUpdateInterval = 0.1 -- Update FOV every 0.1 seconds
game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
    if FOVUpdateInterval <= 0 then
        updateFOVCircle()
        FOVUpdateInterval = 0.1 -- Reset interval
    else
        FOVUpdateInterval = FOVUpdateInterval - deltaTime
    end
end)

-- Function to check if the player is in the SafePlayers list
local function isSafePlayer(player)
    for _, safePlayer in pairs(SafePlayers) do
        if player.Name == safePlayer then
            return true
        end
    end
    return false
end

local function getClosestPlayerToCenter()
    local centerScreenPosition = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
    local closestPlayer
    local closestDistance = math.huge
    local localPlayer = game.Players.LocalPlayer
    local camera = workspace.CurrentCamera

    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            -- Check if player is safe
            if isSafePlayer(player) then
                continue
            end

            -- FriendCheck: Skip if player is a friend and FriendCheck is enabled
            if getgenv().Depart["BulletRedirection"].Checks.FriendCheck and localPlayer:IsFriendsWith(player.UserId) then
                continue
            end

            local playerRootPart = player.Character.HumanoidRootPart
            local screenPosition, onScreen = camera:WorldToViewportPoint(playerRootPart.Position)

            if onScreen then
                -- KOCheck: Skip if the player is knocked out and KOCheck is enabled
                local KOd = player.Character:FindFirstChild("BodyEffects") and player.Character.BodyEffects["K.O"].Value
                if getgenv().Depart["BulletRedirection"].Checks.KOCheck and KOd then
                    continue
                end

                local Grabbed = player.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil

                if not Grabbed then
                    -- WallCheck: Raycast to ensure no walls are blocking the view
                    if getgenv().Depart["BulletRedirection"].Checks.WallCheck then
                        local ray = Ray.new(camera.CFrame.Position, playerRootPart.Position - camera.CFrame.Position)
                        local part, position = workspace:FindPartOnRay(ray, localPlayer.Character, false, true)

                        if part and not part:IsDescendantOf(player.Character) then
                            continue
                        end
                    end

                    -- AntiGroundShots: Check if player is falling
                    if getgenv().Depart["BulletRedirection"].Checks.AntiGroundShots then
                        local yVelocity = playerRootPart.Velocity.Y
                        if yVelocity < 0 then -- Player is falling
                            playerRootPart.Velocity = Vector3.new(playerRootPart.Velocity.X, 0, playerRootPart.Velocity.Z) * 0.36
                        end
                    end

                    -- Calculate distance to center and update the closest player
                    local distance = (centerScreenPosition - Vector2.new(screenPosition.X, screenPosition.Y)).Magnitude
                    if distance < closestDistance and distance <= getgenv().BulletRedirectionFOVSize then
                        closestPlayer = player
                        closestDistance = distance
                    end
                end
            end
        end
    end

    return closestPlayer
end

local BulletRedirectionTarget = nil

-- Optimize target finding to run less frequently
local targetUpdateInterval = 0.2 -- Update target every 0.2 seconds
game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
    if targetUpdateInterval <= 0 then
        BulletRedirectionTarget = getClosestPlayerToCenter()
        targetUpdateInterval = 0.2 -- Reset interval
    else
        targetUpdateInterval = targetUpdateInterval - deltaTime
    end
end)

local function isTargetInAir(character)
    return character.Humanoid.FloorMaterial == Enum.Material.Air
end

local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)
mt.__namecall = newcclosure(function(...)
    local args = {...}
    if getgenv().BulletRedirectionEnabled and BulletRedirectionTarget ~= nil and BulletRedirectionTarget.Character and getnamecallmethod() == "FireServer" then
        if args[2] == "UpdateMousePos" or args[2] == "MOUSE" or args[2] == "UpdateMousePosI2" or args[2] == "MousePosUpdate" then
            local hitchance = math.random() <= getgenv().BulletRedirectionHitchance -- Now uses the fraction
            if hitchance then
                local targetPart = isTargetInAir(BulletRedirectionTarget.Character) and getgenv().AirPart or getgenv().HitPart
                local predictionValue = isTargetInAir(BulletRedirectionTarget.Character) and getgenv().AirPrediction_BulletRedirection or getgenv().Prediction_BulletRedirection

                args[3] = BulletRedirectionTarget.Character[targetPart].Position + (BulletRedirectionTarget.Character[targetPart].Velocity * predictionValue)
                return old(unpack(args))
            end
        end
    end
    return old(...)
end)
setreadonly(mt, true)
end
if Depart.Triggerbot.Enabled then
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local camera = workspace.CurrentCamera
local client = players.LocalPlayer

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 1
fovCircle.NumSides = 150
fovCircle.Radius = getgenv().Depart.Triggerbot.FOVSize
fovCircle.Color = Color3.fromRGB(0, 0, 0)
fovCircle.Transparency = 0.5
fovCircle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
fovCircle.Visible = getgenv().Depart.Triggerbot.FOVShow

local function TriggerbotVelocity(target, time)
    local position = target.Position
    local velocity = target.Velocity
    return position + velocity * time
end

local function PositionTolerance(position, tolerance)
    local screenPoint = camera:WorldToViewportPoint(position)
    local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    local distanceFromCenter = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude
    return distanceFromCenter <= tolerance
end

local function IsWithinDistance(player)
    local character = player.Character
    if not character then return false end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return false end

    local clientCharacter = client.Character
    local clientRootPart = clientCharacter and clientCharacter:FindFirstChild("HumanoidRootPart")
    if not clientRootPart then return false end

    local distance = (humanoidRootPart.Position - clientRootPart.Position).Magnitude
    return distance <= getgenv().Depart.Triggerbot.Distance
end

local function IsInFOV(player)
    local character = player.Character
    if not character then return false end

    for _, aimPartName in ipairs(getgenv().Depart.Triggerbot.AimParts) do
        local aimPart = character:FindFirstChild(aimPartName)
        if aimPart then
            local rootPosition = camera:WorldToViewportPoint(aimPart.Position)
            local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)

            if PositionTolerance(aimPart.Position, getgenv().Depart.Triggerbot.FOVSize) then
                return true
            end
        end
    end

    return false
end

local function IsWhitelisted(toolName)
    if not getgenv().Depart.Triggerbot.UseWhitelist then
        return true
    end
    
    for _, name in ipairs(getgenv().Depart.Triggerbot.Whitelisted) do
        if toolName == name then
            return true
        end
    end
    return false
end

local function WallCheck(target)
    local origin = camera.CFrame.Position
    local direction = (target.Position - origin).Unit
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {client.Character, target.Parent}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    local result = workspace:Raycast(origin, direction * (target.Position - origin).Magnitude, raycastParams)
    return result == nil
end

local function KOCheck(player)
    local KOd = player.Character:FindFirstChild("BodyEffects") and player.Character.BodyEffects["K.O"].Value
    local Grabbed = player.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
    return not (KOd or Grabbed)
end

local function TriggerBot()
    if getgenv().Depart.Triggerbot.Enabled then
        local clientCharacter = client.Character
        if clientCharacter then
            local tool = clientCharacter:FindFirstChildOfClass("Tool")
            if tool and IsWhitelisted(tool.Name) then
                for _, player in ipairs(players:GetPlayers()) do
                    if player ~= client and IsInFOV(player) and IsWithinDistance(player) then
                        local character = player.Character
                        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

                        if character and humanoidRootPart and (not getgenv().Depart.Triggerbot.WallCheck or WallCheck(humanoidRootPart)) and (not getgenv().Depart.Triggerbot.KOCheck or KOCheck(player)) then
                            local predictedPosition = humanoidRootPart.Position

                            if getgenv().Depart.Triggerbot.UsePrediction then
                                predictedPosition = TriggerbotVelocity(humanoidRootPart, getgenv().Depart.Triggerbot.Prediction)
                            end

                            if PositionTolerance(predictedPosition, getgenv().Depart.Triggerbot.Tolerance) then
                                wait(getgenv().Depart.Triggerbot.Delay)
                                tool:Activate()
                                wait(getgenv().Depart.Triggerbot.TapDelay)
                            end
                        end
                    end
                end
            end
        end
    end
end

runService.RenderStepped:Connect(function()
    fovCircle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    fovCircle.Visible = getgenv().Depart.Triggerbot.FOVShow
end)

runService.Heartbeat:Connect(TriggerBot)
end
if Depart.Utility.Macro then
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local camera = game.Workspace.CurrentCamera
    local runService = game:GetService("RunService")
 
    local enabled = true -- Initially set to false
 
    -- Function to update the character's facing direction
    local function updateCharacterFacing()
        if enabled and character and character.PrimaryPart then
            local cameraCFrame = camera.CFrame
            local lookAtPosition = cameraCFrame.Position + cameraCFrame.LookVector * 100 -- 100 studs ahead of the camera
            lookAtPosition = Vector3.new(lookAtPosition.x, character.PrimaryPart.Position.y, lookAtPosition.z)
            character:SetPrimaryPartCFrame(CFrame.new(character.PrimaryPart.Position, lookAtPosition))
        end
    end
 
    -- Connect the update function to the RenderStepped event to update every frame
    runService.RenderStepped:Connect(updateCharacterFacing)
 
    -- Update the character when respawning
    player.CharacterAdded:Connect(function(newCharacter)
        character = newCharacter
        character:WaitForChild("PrimaryPart")
    end)
 
    local screenGui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
    screenGui.Name = "MacroGui"
    screenGui.Enabled = true -- Show the GUI
    screenGui.ResetOnSpawn = false -- Ensures the GUI doesn't reset on player respawn
 
    -- Parent Frame (Draggable)
    local parentFrame = Instance.new("Frame", screenGui)
    parentFrame.Size = UDim2.new(0, 180, 0, 70) -- Moderate size
    parentFrame.Position = UDim2.new(0.9, -190, 0.95, -80) -- Adjusted position
    parentFrame.BackgroundColor3 = Color3.fromRGB(24, 24, 24)
    parentFrame.BorderSizePixel = 0
 
    local uiCornerParent = Instance.new("UICorner", parentFrame)
    uiCornerParent.CornerRadius = UDim.new(0, 10)
 
    -- Child Frame (Inside Parent)
    local frame = Instance.new("Frame", parentFrame)
    frame.Size = UDim2.new(1, -15, 1, -15)
    frame.Position = UDim2.new(0, 5, 0, 5)
    frame.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
    frame.BorderSizePixel = 0
 
    local uiCorner = Instance.new("UICorner", frame)
    uiCorner.CornerRadius = UDim.new(0, 10)
 
    -- Draggable support for the parent frame
    local function makeDraggable(frame)
        local dragging
        local dragInput
        local dragStart
        local startPos
 
        local function update(input)
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
 
        frame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = frame.Position
 
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = true
                    end
                end)
            end
        end)
 
        frame.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                dragInput = input
            end
        end)
 
        runService.Heartbeat:Connect(function()
            if dragging and dragInput then
                update(dragInput)
            end
        end)
    end
 
    makeDraggable(parentFrame)
 
    -- Button
    local toggleButton = Instance.new("TextButton", frame)
    toggleButton.Size = UDim2.new(1, 0, 1, 0)
    toggleButton.Text = "Macro: OFF"
    toggleButton.BackgroundColor3 = Color3.fromRGB(246, 198, 208)
    toggleButton.TextColor3 = Color3.fromRGB(246, 198, 208)
    toggleButton.Font = Enum.Font.SourceSansBold
    toggleButton.TextScaled = true
    toggleButton.BorderSizePixel = 0
 
    local buttonCorner = Instance.new("UICorner", toggleButton)
    buttonCorner.CornerRadius = UDim.new(0, 10)
 
    toggleButton.MouseButton1Click:Connect(function()
        enabled = not enabled
        toggleButton.Text = enabled and "Macro: ON" or "Macro: OFF"
        toggleButton.BackgroundColor3 = enabled and Color3.fromRGB(135, 206, 235) or Color3.fromRGB(135, 206, 235)
    end)
end
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "KeyBoard",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/advxzivhsjjdhxhsidifvsh/mobkeyboard/main/main.txt", true))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "ResolverLagsInSomeGames",
   Callback = function()
   local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer

local ScreenGui = Instance.new("ScreenGui")
local ToggleButton = Instance.new("TextButton")
local Frame = Instance.new("Frame")
local NotificationFrame = Instance.new("Frame")
local NotificationText = Instance.new("TextLabel")
local NotificationTitle = Instance.new("TextLabel")

ScreenGui.Name = "ToggleScriptGUI"
ScreenGui.ResetOnSpawn = false -- Prevent GUI from being destroyed on respawn
ScreenGui.Parent = localPlayer:WaitForChild("PlayerGui")

Frame.Name = "MainFrame"
Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 60)
Frame.Position = UDim2.new(0, 50, 0, 50)
Frame.Size = UDim2.new(0, 200, 0, 100)
Frame.Active = true
Frame.Draggable = true

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 16)
UICorner.Parent = Frame

local UIGradient = Instance.new("UIGradient")
UIGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0.00, Color3.fromRGB(10, 10, 40)),
    ColorSequenceKeypoint.new(1.00, Color3.fromRGB(40, 40, 80))
}
UIGradient.Parent = Frame

ToggleButton.Name = "ToggleButton"
ToggleButton.Parent = Frame
ToggleButton.BackgroundColor3 = Color3.fromRGB(0, 100, 255)
ToggleButton.Position = UDim2.new(0.1, 0, 0.3, 0)
ToggleButton.Size = UDim2.new(0.8, 0, 0.4, 0)
ToggleButton.Text = "Resolver: OFF"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.Font = Enum.Font.SourceSansBold
ToggleButton.TextSize = 18

local ButtonUICorner = Instance.new("UICorner")
ButtonUICorner.CornerRadius = UDim.new(0, 16)
ButtonUICorner.Parent = ToggleButton

local ButtonUIGradient = Instance.new("UIGradient")
ButtonUIGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 150, 255)),
    ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 50, 150))
}
ButtonUIGradient.Parent = ToggleButton

-- this shows the notification for the one who made it, skidders remove this but idc, you can change it, fuck skidders ???? 
NotificationFrame.Name = "NotificationFrame"
NotificationFrame.Parent = ScreenGui
NotificationFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
NotificationFrame.BackgroundTransparency = 0.5
NotificationFrame.Position = UDim2.new(0.5, -100, 0.5, -50)
NotificationFrame.Size = UDim2.new(0, 200, 0, 100)

local NotificationUICorner = Instance.new("UICorner")
NotificationUICorner.CornerRadius = UDim.new(0, 16)
NotificationUICorner.Parent = NotificationFrame

NotificationTitle.Name = "NotificationTitle"
NotificationTitle.Parent = NotificationFrame
NotificationTitle.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
NotificationTitle.BackgroundTransparency = 1
NotificationTitle.Size = UDim2.new(1, 0, 0.4, 0)
NotificationTitle.Font = Enum.Font.SourceSansBold
NotificationTitle.Text = "Resolver OP"
NotificationTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
NotificationTitle.TextSize = 24

NotificationText.Name = "NotificationText"
NotificationText.Parent = NotificationFrame
NotificationText.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
NotificationText.BackgroundTransparency = 1
NotificationText.Position = UDim2.new(0, 0, 0.4, 0)
NotificationText.Size = UDim2.new(1, 0, 0.6, 0)
NotificationText.Font = Enum.Font.SourceSans
NotificationText.Text = "Made By @ Ovni"  -- Changed here
NotificationText.TextColor3 = Color3.fromRGB(255, 255, 255)
NotificationText.TextSize = 18

wait(5)
NotificationFrame:Destroy()

local scriptEnabled = false
local connection

local function onHeartbeat()
    for _, Target in pairs(Players:GetPlayers()) do
        if Target ~= localPlayer and Target.Character then
            for _, Part in pairs(Target.Character:GetDescendants()) do
                if Part:IsA("BasePart") then
                    Part.Velocity = Target.Character.Humanoid.MoveDirection * 16
                    Part.AssemblyLinearVelocity = Target.Character.Humanoid.MoveDirection * 16
                end
            end
        end
    end
end

ToggleButton.MouseButton1Click:Connect(function()
    scriptEnabled = not scriptEnabled
    if scriptEnabled then
        ToggleButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        ToggleButton.Text = "Resolver: ON"
        ButtonUIGradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 255, 150)),
            ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 150, 50))
        }
        if not connection then
            connection = RunService.Heartbeat:Connect(onHeartbeat)
        end
    else
        ToggleButton.BackgroundColor3 = Color3.fromRGB(0, 100, 255)
        ToggleButton.Text = "Resolver: OFF"
        ButtonUIGradient.Color = ColorSequence.new{
            ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 150, 255)),
            ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 50, 150))
        }
        if connection then
            connection:Disconnect()
            connection = nil
        end
    end
end)
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "FpsBoostandLagReducer",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-FpsBoost-9260"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "FpsBoostandLagReducer2",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-FPS-BOOST-2022-3864"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Azure ESP",
   Callback = function()
   -- esp.lua
--// Variables
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer
local camera = workspace.CurrentCamera
local cache = {}

local bones = {
    {"Head", "UpperTorso"},
    {"UpperTorso", "RightUpperArm"},
    {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"},
    {"UpperTorso", "LeftUpperArm"},
    {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "LowerTorso"},
    {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"},
    {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"},
    {"RightLowerLeg", "RightFoot"}
}

--// Settings
local ESP_SETTINGS = {
    BoxOutlineColor = Color3.new(246, 198, 208),
    BoxColor = Color3.new(1, 1, 1),
    FilledBoxColor = Color3.new(1, 1, 1),
    NameColor = Color3.new(135, 206, 235),
    HealthOutlineColor = Color3.new(0, 0, 0),
    HealthHighColor = Color3.new(0, 1, 0),
    HealthLowColor = Color3.new(1, 0, 0),
    HealthColor = Color3.new(1, 1, 1),
    AnimatedHealthBars = false,
    DistanceColor = Color3.new(1, 1, 1),
    HealthBasedColor = false,
    CharSize = Vector2.new(4, 6),
    Teamcheck = false,
    WallCheck = false,
    Enabled = true,
    ShowFilledBox = false,
    ShowBox = false,
    BoxType = "Normal",
    ShowName = true,
    ShowHealth = false,
    ShowDistance = false,
    ShowTracer = false,
    TracerThickness = 1,
    TracerPosition = "Bottom",
}

local function create(class, properties)
    local drawing = Drawing.new(class)
    for property, value in pairs(properties) do
        drawing[property] = value
    end
    return drawing
end

local function createEsp(player)
    local esp = {
        tracer = create("Line", {
            Thickness = ESP_SETTINGS.TracerThickness,
            Color = ESP_SETTINGS.TracerColor,
            Transparency = 1
        }),
        boxOutline = create("Square", {
            Color = ESP_SETTINGS.BoxOutlineColor,
            Thickness = 2,
            Filled = false
        }),
        box = create("Square", {
            Color = ESP_SETTINGS.BoxColor,
            Thickness = 1,
            Filled = false
        }),
        filledBox = create("Square", {
            Color = ESP_SETTINGS.BoxColor,
            Thickness = 1,
            Transparency = 0.3,
            Filled = true
        }),
        name = create("Text", {
            Color = ESP_SETTINGS.NameColor,
            Outline = true,
            Center = true,
            Size = 11
        }),
        healthOutline = create("Line", {
            Thickness = 3,
            Color = ESP_SETTINGS.HealthOutlineColor
        }),
        health = create("Line", {
            Thickness = 1
        }),
        distance = create("Text", {
            Color = Color3.new(1, 1, 1),
            Size = 12,
            Outline = true,
            Center = true
        }),
        boxLines = {},
    }

    cache[player] = esp
end

local function isPlayerBehindWall(player)
    local character = player.Character
    if not character then
        return false
    end

    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        return false
    end

    local ray = Ray.new(camera.CFrame.Position, (rootPart.Position - camera.CFrame.Position).Unit * (rootPart.Position - camera.CFrame.Position).Magnitude)
    local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, {localPlayer.Character, character})
    
    return hit and hit:IsA("Part")
end

local function removeEsp(player)
    local esp = cache[player]
    if not esp then return end

    for _, drawing in pairs(esp) do
        drawing:Remove()
    end

    cache[player] = nil
end

function lerp(a, b, t)
    return a + (b - a) * t
end


local function updateEsp()
    for player, esp in pairs(cache) do
        local character, team = player.Character, player.Team
        if character and (not ESP_SETTINGS.Teamcheck or (team and team ~= localPlayer.Team)) then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local head = character:FindFirstChild("Head")
            local humanoid = character:FindFirstChild("Humanoid")
            local isBehindWall = ESP_SETTINGS.WallCheck and isPlayerBehindWall(player)
            local shouldShow = not isBehindWall and ESP_SETTINGS.Enabled
            if rootPart and head and humanoid and shouldShow then
                local position, onScreen = camera:WorldToViewportPoint(rootPart.Position)
                if onScreen then
                    local hrp2D = camera:WorldToViewportPoint(rootPart.Position)
                    local charSize = (camera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 3, 0)).Y - camera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, 2.6, 0)).Y) / 2
                    local boxSize = Vector2.new(math.floor(charSize * 1.4), math.floor(charSize * 1.9))
                    local boxPosition = Vector2.new(math.floor(hrp2D.X - charSize * 1.4 / 2), math.floor(hrp2D.Y - charSize * 1.6 / 2))

                    if ESP_SETTINGS.ShowName and ESP_SETTINGS.Enabled then
                        esp.name.Visible = true
                        esp.name.Text = string.lower(player.Name)
                        esp.name.Position = Vector2.new(boxSize.X / 2 + boxPosition.X, boxPosition.Y - 16)
                        esp.name.Color = ESP_SETTINGS.NameColor
                    else
                        esp.name.Visible = false
                    end

                    if ESP_SETTINGS.ShowFilledBox and ESP_SETTINGS.Enabled then
                        esp.filledBox.Position = boxPosition
                        esp.filledBox.Size = boxSize
                        esp.filledBox.Color = ESP_SETTINGS.FilledBoxColor
                        esp.filledBox.Visible = true
                    else
                        esp.filledBox.Visible = false
                    end

                    if ESP_SETTINGS.ShowBox and ESP_SETTINGS.Enabled then
                        if ESP_SETTINGS.BoxType == "Normal" then
                            esp.boxOutline.Size = boxSize
                            esp.boxOutline.Position = boxPosition
                            esp.box.Size = boxSize
                            esp.box.Position = boxPosition
                            esp.box.Color = ESP_SETTINGS.BoxColor
                            esp.box.Visible = true
                            esp.boxOutline.Visible = true
                            for _, line in ipairs(esp.boxLines) do
                                line:Remove()
                            end
                        elseif ESP_SETTINGS.BoxType == "Corner" then
                            local lineW = (boxSize.X / 3)
                            local lineH = (boxSize.Y / 3)
                        
                            if #esp.boxLines == 0 then
                                for i = 1, 16 do
                                    local boxLine = create("Line", {
                                        Thickness = 1,
                                        Color = ESP_SETTINGS.BoxColor,
                                        Transparency = 1
                                    })
                                    esp.boxLines[#esp.boxLines + 1] = boxLine
                                end
                            end
                        
                            local boxLines = esp.boxLines
                        
                            -- outline
                            for i = 1, 8 do
                                boxLines[i].Thickness = 2
                                boxLines[i].Color = ESP_SETTINGS.BoxOutlineColor
                                boxLines[i].Transparency = 1
                            end
                        
                            boxLines[1].From = Vector2.new(boxPosition.X, boxPosition.Y)
                            boxLines[1].To = Vector2.new(boxPosition.X, boxPosition.Y + lineH)
                        
                            boxLines[2].From = Vector2.new(boxPosition.X, boxPosition.Y)
                            boxLines[2].To = Vector2.new(boxPosition.X + lineW, boxPosition.Y)
                        
                            boxLines[3].From = Vector2.new(boxPosition.X + boxSize.X - lineW, boxPosition.Y)
                            boxLines[3].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y)
                        
                            boxLines[4].From = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y)
                            boxLines[4].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y + lineH)
                        
                            boxLines[5].From = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y - lineH)
                            boxLines[5].To = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y)
                        
                            boxLines[6].From = Vector2.new(boxPosition.X, boxPosition.Y + boxSize.Y)
                            boxLines[6].To = Vector2.new(boxPosition.X + lineW, boxPosition.Y + boxSize.Y)
                        
                            boxLines[7].From = Vector2.new(boxPosition.X + boxSize.X - lineW, boxPosition.Y + boxSize.Y)
                            boxLines[7].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y + boxSize.Y)
                        
                            boxLines[8].From = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y + boxSize.Y - lineH)
                            boxLines[8].To = Vector2.new(boxPosition.X + boxSize.X, boxPosition.Y + boxSize.Y)
                        
                            -- inline
                            for i = 9, 16 do
                                boxLines[i].From = boxLines[i - 8].From
                                boxLines[i].To = boxLines[i - 8].To
                                boxLines[i].Color = ESP_SETTINGS.BoxColor
                            end
                        
                            for _, line in ipairs(boxLines) do
                                line.Visible = true
                            end
                            esp.box.Visible = false
                            esp.boxOutline.Visible = false
                        end
                    else
                        esp.box.Visible = false
                        esp.boxOutline.Visible = false
                        for _, line in ipairs(esp.boxLines) do
                            line:Remove()
                        end
                        esp.boxLines = {}
                    end

                    if ESP_SETTINGS.ShowHealth and ESP_SETTINGS.Enabled then
                        esp.healthOutline.Visible = true
                        esp.health.Visible = true
                        local health = 0
                        if ESP_SETTINGS.AnimatedHealthBars then
                            health = lerp(health, player.Character.Humanoid.Health, 0.3)
                        else
                            health = player.Character.Humanoid.Health
                        end
                        local healthPercentage = health / player.Character.Humanoid.MaxHealth
                        local healthBarHeight = (health / player.Character.Humanoid.MaxHealth) * boxSize.Y
                        esp.healthOutline.From = Vector2.new(boxPosition.X - 6, boxPosition.Y + boxSize.Y + 1)
                        esp.healthOutline.To = Vector2.new(esp.healthOutline.From.X, esp.healthOutline.From.Y - boxSize.Y - 1)
                        esp.health.From = Vector2.new(boxPosition.X - 6, boxPosition.Y + boxSize.Y)
                        
                        esp.health.To = Vector2.new(boxPosition.X - 6, boxPosition.Y + boxSize.Y - healthBarHeight) + Vector2.new(0, 1)
                        if ESP_SETTINGS.HealthBasedColor then
                            esp.health.Color = ESP_SETTINGS.HealthLowColor:Lerp(ESP_SETTINGS.HealthHighColor, healthPercentage)
                        else
                            esp.health.Color = ESP_SETTINGS.HealthColor
                        end
                    else
                        esp.healthOutline.Visible = false
                        esp.health.Visible = false
                    end

                    if ESP_SETTINGS.ShowDistance and ESP_SETTINGS.Enabled then
                        local distance = (localPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
                        esp.distance.Text = string.format("%.1f studs", distance)
                        esp.distance.Position = Vector2.new(boxPosition.X + boxSize.X / 2, boxPosition.Y + boxSize.Y + 5)
                        esp.distance.Color = ESP_SETTINGS.DistanceColor
                        esp.distance.Visible = true
                    else
                        esp.distance.Visible = false
                    end             

                    if ESP_SETTINGS.ShowTracer and ESP_SETTINGS.Enabled then
                        local tracerY
                        if ESP_SETTINGS.TracerPosition == "Top" then
                            tracerY = 0
                        elseif ESP_SETTINGS.TracerPosition == "Middle" then
                            tracerY = camera.ViewportSize.Y / 2
                        else
                            tracerY = camera.ViewportSize.Y
                        end
                        if ESP_SETTINGS.Teamcheck and player.TeamColor == localPlayer.TeamColor then
                            esp.tracer.Visible = false
                        else
                            esp.tracer.Visible = true
                            esp.tracer.From = Vector2.new(camera.ViewportSize.X / 2, tracerY)
                            esp.tracer.To = Vector2.new(hrp2D.X, hrp2D.Y)
                            esp.tracer.Color = ESP_SETTINGS.TracerColor
                            esp.tracer.Thickness = ESP_SETTINGS.TracerThickness
                        end
                    else
                        esp.tracer.Visible = false
                    end
                else
                    for _, drawing in pairs(esp) do
                        drawing.Visible = false
                    end
                    for _, line in ipairs(esp.boxLines) do
                        line:Remove()
                    end
                    esp.boxLines = {}
                end
            else
                for _, drawing in pairs(esp) do
                    drawing.Visible = false
                end
                for _, line in ipairs(esp.boxLines) do
                    line:Remove()
                end
                esp.boxLines = {}
            end
        else
            for _, drawing in pairs(esp) do
                drawing.Visible = false
            end
            for _, line in ipairs(esp.boxLines) do
                line:Remove()
            end
            esp.boxLines = {}
        end
    end
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= localPlayer then
        createEsp(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= localPlayer then
        createEsp(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    removeEsp(player)
end)

RunService.RenderStepped:Connect(updateEsp)
return ESP_SETTINGS
   end,
})


local Button = UseFulTab:CreateButton({
   Name = "ESP 1",
   Callback = function()
   loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Esp-open-source-15582"))()
   end,
})

local Button = UseFulTab:CreateButton({
   Name = "Box ESP",
   Callback = function()
   --// Universal Box ESP (Works on Arsenal and other games)
 
-- settings
local settings = {
   defaultcolor = Color3.fromRGB(255,0,0),
   teamcheck = false,
   teamcolor = true
};
 
-- services
local runService = game:GetService("RunService");
local players = game:GetService("Players");
 
-- variables
local localPlayer = players.LocalPlayer;
local camera = workspace.CurrentCamera;
 
-- functions
local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new;
local tan, rad = math.tan, math.rad;
local round = function(...) local a = {}; for i,v in next, table.pack(...) do a[i] = math.round(v); end return unpack(a); end;
local wtvp = function(...) local a, b = camera.WorldToViewportPoint(camera, ...) return newVector2(a.X, a.Y), b, a.Z end;
 
local espCache = {};
local function createEsp(player)
   local drawings = {};
 
   drawings.box = newDrawing("Square");
   drawings.box.Thickness = 1;
   drawings.box.Filled = false;
   drawings.box.Color = settings.defaultcolor;
   drawings.box.Visible = false;
   drawings.box.ZIndex = 2;
 
   drawings.boxoutline = newDrawing("Square");
   drawings.boxoutline.Thickness = 3;
   drawings.boxoutline.Filled = false;
   drawings.boxoutline.Color = newColor3();
   drawings.boxoutline.Visible = false;
   drawings.boxoutline.ZIndex = 1;
 
   espCache[player] = drawings;
end
 
local function removeEsp(player)
   if rawget(espCache, player) then
       for _, drawing in next, espCache[player] do
           drawing:Remove();
       end
       espCache[player] = nil;
   end
end
 
local function updateEsp(player, esp)
   local character = player and player.Character;
   if character then
       local cframe = character:GetModelCFrame();
       local position, visible, depth = wtvp(cframe.Position);
       esp.box.Visible = visible;
       esp.boxoutline.Visible = visible;
 
       if cframe and visible then
           local scaleFactor = 1 / (depth * tan(rad(camera.FieldOfView / 2)) * 2) * 1000;
           local width, height = round(4 * scaleFactor, 5 * scaleFactor);
           local x, y = round(position.X, position.Y);
 
           esp.box.Size = newVector2(width, height);
           esp.box.Position = newVector2(round(x - width / 2, y - height / 2));
           esp.box.Color = settings.teamcolor and player.TeamColor.Color or settings.defaultcolor;
 
           esp.boxoutline.Size = esp.box.Size;
           esp.boxoutline.Position = esp.box.Position;
       end
   else
       esp.box.Visible = false;
       esp.boxoutline.Visible = false;
   end
end
 
-- main
for _, player in next, players:GetPlayers() do
   if player ~= localPlayer then
       createEsp(player);
   end
end
 
players.PlayerAdded:Connect(function(player)
   createEsp(player);
end);
 
players.PlayerRemoving:Connect(function(player)
   removeEsp(player);
end)
 
runService:BindToRenderStep("esp", Enum.RenderPriority.Camera.Value, function()
   for player, drawings in next, espCache do
       if settings.teamcheck and player.Team == localPlayer.Team then
           continue;
       end
 
       if drawings and player ~= localPlayer then
           updateEsp(player, drawings);
       end
   end
end)

   end,
})

local Button = UseFulTab:CreateButton({
   Name = "esp highlight",
   Callback = function()
   local FillColor = Color3.fromRGB(180,220,255)
local DepthMode = "AlwaysOnTop"
local FillTransparency = 0.5
local OutlineColor = Color3.fromRGB(255,255,255)
local OutlineTransparency = 0

local CoreGui = game:FindService("CoreGui")
local Players = game:FindService("Players")
local lp = Players.LocalPlayer
local connections = {}

local Storage = Instance.new("Folder")
Storage.Parent = CoreGui
Storage.Name = "Highlight_Storage"

local function Highlight(plr)
    local Highlight = Instance.new("Highlight")
    Highlight.Name = plr.Name
    Highlight.FillColor = FillColor
    Highlight.DepthMode = DepthMode
    Highlight.FillTransparency = FillTransparency
    Highlight.OutlineColor = OutlineColor
    Highlight.OutlineTransparency = 0
    Highlight.Parent = Storage
    
    local plrchar = plr.Character
    if plrchar then
        Highlight.Adornee = plrchar
    end

    connections[plr] = plr.CharacterAdded:Connect(function(char)
        Highlight.Adornee = char
    end)
end

Players.PlayerAdded:Connect(Highlight)
for i,v in next, Players:GetPlayers() do
    Highlight(v)
end

Players.PlayerRemoving:Connect(function(plr)
    local plrname = plr.Name
    if Storage[plrname] then
        Storage[plrname]:Destroy()
    end
    if connections[plr] then
        connections[plr]:Disconnect()
    end
end)
   end,
})

local ExploitsTab = Window:CreateTab("Exploits", "crown")
local Section = ExploitsTab:CreateSection("Exploits")

local Button = ExploitsTab:CreateButton({
   Name = "Azure Exploits",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/Sigma-3131/Scripts/main/Azure%20Mobile"))()
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "Elysian Exploits",
   Callback = function()
   getgenv().Elysian = {
    ['Camlock'] = {
        ['Manual Prediction'] = 0.1475,
        ['Auto Prediction'] = {
            ['Enabled'] = true,
            ['Ping'] = {
                ['20'] = 0.10036,
                ['30'] = 0.1130,
                ['40'] = 0.13544,
                ['50'] = 0.1357,
                ['60'] = 0.13598,
                ['70'] = 0.13892,
                ['80'] = 0.1403,
                ['90'] = 0.1446,
                ['100'] = 0.1475
            }
        },
        ['Smoothing'] = {
            ['Enabled'] = false,
            ['Value'] = 0.013
        },
        ['Offset'] = {
            ['Jump'] = -1,
            ['Fall'] = -1,
        },
        ['Auto Shoot'] = true,
        ['Airshot Function'] = {
            ['Enabled'] = true,
            ['Part'] = "LowerTorso"
        },
        ['Target Part'] = "HumanoidRootPart"
    },
    ['HvH'] = {
        ['Target Strafe'] = {
            ['Enabled'] = true,
            ['Speed'] = 100,
            ['Distance'] = 8,
            ['Height'] = 8,
        },
        ['Cframe Walk'] = {
            ['Enabled'] = true,
            ['Amount'] = 4
        }
    }
}

local userInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local client = players.LocalPlayer
local camera = workspace.CurrentCamera
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")

local Locking = false
local Plr = nil
local strafing = false
local cframing = false
local auto_shooting = false

local playerData = {}
local SMOOTHNESS_FACTOR = 2

local function GetEvent()
    for _, v in pairs(game.ReplicatedStorage:GetChildren()) do
        if v.Name == "MainEvent" or v.Name == "Bullets" or v.Name == ".gg/untitledhood" or v.Name == "Remote" or v.Name == "MAINEVENT" or v.Name == ".gg/flamehood" then
            return v
        end
    end
end

local function GetArgs()
    local PlaceId = game.PlaceId
    if PlaceId == 2788229376 or PlaceId == 4106313503 or PlaceId == 11143225577 or PlaceId == 17319408836 or PlaceId == 18110728826 then
        return "UpdateMousePosI"
    elseif PlaceId == 5602055394 or PlaceId == 7951883376 then
        return "MousePos"
    elseif PlaceId == 10100958808 or PlaceId == 12645617354 or PlaceId == 14171242539 or PlaceId == 14412436145 or PlaceId == 14412355918 or PlaceId == 14413720089 or PlaceId == 17403265390 or PlaceId == 17403166075 or PlaceId == 17403262882 or PlaceId == 15186202290 or PlaceId == 15763494605 then
        return "MOUSE"
    elseif PlaceId == 9825515356 then
        return "MousePosUpdate"
    elseif PlaceId == 15166543806 then
        return "MoonUpdateMousePos"
    elseif PlaceId == 16033173781 or PlaceId == 7213786345 then
        return "UpdateMousePosI"
    else
        return "UpdateMousePos"
    end
end

local mainEvent = GetEvent()

function GetClosestToCenter()
    local closestDist = math.huge
    local closestPlr = nil
    local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    
    for _, v in ipairs(players:GetPlayers()) do
        if v ~= client and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
            local screenPos, onScreen = camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
            if onScreen then
                local distToCenter = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
                if distToCenter < closestDist then
                    closestPlr = v
                    closestDist = distToCenter
                end
            end
        end
    end
    return closestPlr
end

local function getPart()
    if not Plr or not Plr.Character then
        return nil
    end

    local humanoid = Plr.Character:FindFirstChild("Humanoid")
    if not humanoid then
        return nil
    end

    if humanoid:GetState() == Enum.HumanoidStateType.Freefall and getgenv().Elysian['Camlock']['Airshot Function']['Enabled'] then
        local airshotPart = Plr.Character:FindFirstChild(getgenv().Elysian['Camlock']['Airshot Function']['Part'])
        if airshotPart then
            return airshotPart
        end
    end

    local targetPart = Plr.Character:FindFirstChild(getgenv().Elysian['Camlock']['Target Part'])
    if targetPart then
        return targetPart
    end

    return Plr.Character:FindFirstChild("HumanoidRootPart")
end

local function getPredictionValue()
    if getgenv().Elysian['Camlock']['Auto Prediction']['Enabled'] then
        local ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
        local pingTable = getgenv().Elysian['Camlock']['Auto Prediction']['Ping']
        
        for i = ping, 0, -1 do
            if pingTable[tostring(i)] then
                return pingTable[tostring(i)]
            end
        end
        
        return pingTable['100']
    else
        return getgenv().Elysian['Camlock']['Manual Prediction']
    end
end

local function calculatePosition(victim, velocity)
    local prediction = getPredictionValue()
    local jumpOffset = getgenv().Elysian['Camlock']['Offset']['Jump']
    local fallOffset = getgenv().Elysian['Camlock']['Offset']['Fall']
    
    local playerData = playerData[victim.Parent.Parent]
    if not playerData then
        playerData = {
            SmoothedVelocity = velocity
        }
        playerData[victim.Parent.Parent] = playerData
    end
    
    playerData.SmoothedVelocity = playerData.SmoothedVelocity:Lerp(velocity, 0.5)
    
    local pos = victim.Position + playerData.SmoothedVelocity * prediction

    if victim.Parent and victim.Parent:FindFirstChild("Humanoid") then
        local humanoid = victim.Parent.Humanoid
        if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
            pos = pos + Vector3.new(0, jumpOffset, 0)
        elseif humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            pos = pos + Vector3.new(0, fallOffset, 0)
        end
    end

    return pos
end

local function CharAdded()
    if Locking and Plr and Plr.Character and playerData[Plr] then
        local Part = getPart()
        if Part then
            local Position = calculatePosition(Part, playerData[Plr].Velocity)
            mainEvent:FireServer(GetArgs(), Position)
        end
    end
end

client.Character.ChildAdded:Connect(function(child)
    if child:IsA("Tool") then
        child.Activated:Connect(CharAdded)
    end
end)

client.CharacterAdded:Connect(function(character)
    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            child.Activated:Connect(CharAdded)
        end
    end)
end)

local function Process(player, dT)
    if not player or not player.Character then
        return
    end

    local PrimaryPart = player.Character:FindFirstChild("HumanoidRootPart")
    if not PrimaryPart then
        return
    end

    if not playerData[player] then
        playerData[player] = {
            PreviousPosition = PrimaryPart.Position,
            Velocity = Vector3.new(0, 0, 0),
            OnScreen = false,
            ScreenPosition = Vector2.new(0, 0)
        }
    end

    local CurrentPosition = PrimaryPart.Position
    local PreviousPosition = playerData[player].PreviousPosition
    local Displacement = CurrentPosition - PreviousPosition

    local targetVelocity = Displacement / dT
    playerData[player].Velocity = playerData[player].Velocity:Lerp(targetVelocity, 0.5)
    playerData[player].PreviousPosition = CurrentPosition
    
    local ScreenPosition, OnScreen = workspace.CurrentCamera:WorldToViewportPoint(CurrentPosition)

    playerData[player].OnScreen = OnScreen
    playerData[player].ScreenPosition = Vector2.new(ScreenPosition.X, ScreenPosition.Y)
end

local strafeAngle = 0

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = CoreGui
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local function SavePositions(positions)
    local json = HttpService:JSONEncode(positions)
    writefile("button_positions.json", json)
end

local function LoadPositions()
    if isfile("button_positions.json") then
        local json = readfile("button_positions.json")
        return HttpService:JSONDecode(json)
    end
    return {}
end

local savedPositions = LoadPositions()

local function CreateButton(name, defaultPosition, callback)
    local Button = Instance.new("TextButton")
    Button.Size = UDim2.new(0, 100, 0, 50)
    Button.Position = savedPositions[name] and UDim2.new(0, savedPositions[name].X, 0, savedPositions[name].Y) or defaultPosition
    Button.Text = name
    Button.Parent = ScreenGui
    Button.BackgroundColor3 = Color3.fromRGB(246, 198, 208)
    Button.BorderSizePixel = 0
    Button.Font = Enum.Font.Code
    Button.TextColor3 = Color3.new(0, 0, 0)
    Button.TextSize = 16
    Button.AutoButtonColor = false

    local Corner = Instance.new("UICorner")
    Corner.CornerRadius = UDim.new(0, 8)
    Corner.Parent = Button

    local Shadow = Instance.new("Frame")
    Shadow.Size = UDim2.new(1, 6, 1, 6)
    Shadow.Position = UDim2.new(0, -3, 0, -3)
    Shadow.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    Shadow.BackgroundTransparency = 0.7
    Shadow.ZIndex = -1
    Shadow.Parent = Button

    local ShadowCorner = Instance.new("UICorner")
    ShadowCorner.CornerRadius = UDim.new(0, 8)
    ShadowCorner.Parent = Shadow

    local isActive = false

    local function updateButtonState()
        local targetColor = isActive and Color3.fromRGB(135, 206, 235) or Color3.fromRGB(246, 198, 208)
        local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = game:GetService("TweenService"):Create(Shadow, tweenInfo, {BackgroundColor3 = targetColor})
        tween:Play()
    end

    Button.MouseButton1Click:Connect(function()
        isActive = not isActive
        updateButtonState()
        callback(isActive)
    end)

    local dragStart, startPos

    Button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragStart = input.Position
            startPos = Button.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragStart = nil
                    savedPositions[name] = {X = Button.Position.X.Offset, Y = Button.Position.Y.Offset}
                    SavePositions(savedPositions)
                end
            end)
        end
    end)

    Button.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement then
            if dragStart then
                local delta = input.Position - dragStart
                Button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end
    end)
    
    return Button, function() return isActive end
end

local CamlockButton, getCamlockState = CreateButton("Camlock", UDim2.new(0, 10, 0, 10), function(state)
    Locking = state
    if Locking then
        Plr = GetClosestToCenter()
    else
        Plr = nil
    end
end)

if getgenv().Elysian['HvH']['Target Strafe']['Enabled'] then
    local StrafeButton, getStrafeState = CreateButton("Strafe", UDim2.new(0, 10, 0, 70), function(state)
        strafing = state
    end)
end

if getgenv().Elysian['HvH']['Cframe Walk']['Enabled'] then
    local CframeButton, getCframeState = CreateButton("Cframe", UDim2.new(0, 10, 0, 130), function(state)
        cframing = state
    end)
end

if getgenv().Elysian['Camlock']['Auto Shoot'] then
    local AutoShootButton, getAutoShootState = CreateButton("AutoShoot", UDim2.new(0, 10, 0, 190), function(state)
        auto_shooting = state
    end)
end

local function AutoShoot()
    if Locking and Plr then
        local character = client.Character
        if character then
            local tool = character:FindFirstChildOfClass("Tool")
            if tool and tool:IsA("Tool") then
                tool:Activate()
            end
        end
    end
end

runService.Heartbeat:Connect(function(dT)
    for _, player in ipairs(players:GetPlayers()) do
        if player ~= client then
            Process(player, dT)
        end
    end

    if getgenv().Elysian['HvH']['Target Strafe']['Enabled'] and Locking and strafing and Plr and Plr.Character then
        local targetHRP = Plr.Character:FindFirstChild("HumanoidRootPart")
        if targetHRP then
            strafeAngle = strafeAngle + math.rad(getgenv().Elysian['HvH']['Target Strafe']['Speed'])
            
            local distance = getgenv().Elysian['HvH']['Target Strafe']['Distance']
            local height = getgenv().Elysian['HvH']['Target Strafe']['Height']
            
            local offsetX = math.sin(strafeAngle) * distance
            local offsetZ = math.cos(strafeAngle) * distance
            local offsetY = math.sin(strafeAngle * 2) * height
            
            local predictedPosition = calculatePosition(targetHRP, playerData[Plr].Velocity)
            local strafePosition = predictedPosition + Vector3.new(offsetX, offsetY, offsetZ)
            
            if client.Character and client.Character:FindFirstChild("HumanoidRootPart") then
                client.Character.HumanoidRootPart.CFrame = CFrame.new(strafePosition, predictedPosition)
            end
        end
    end

    if cframing and getgenv().Elysian['HvH']['Cframe Walk']['Enabled'] and client.Character and client.Character:FindFirstChild("Humanoid") and client.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = client.Character.HumanoidRootPart
        local moveDirection = client.Character.Humanoid.MoveDirection
        hrp.CFrame = hrp.CFrame + (moveDirection * getgenv().Elysian['HvH']['Cframe Walk']['Amount'])
    end

    if auto_shooting then
        AutoShoot()
    end
end)

runService.RenderStepped:Connect(function()
    if Locking and Plr and Plr.Character and playerData[Plr] then
        local Part = getPart()
        if Part then
            local Position = calculatePosition(Part, playerData[Plr].Velocity)
            local Main = CFrame.new(camera.CFrame.p, Position)
            
            if getgenv().Elysian['Camlock']['Smoothing']['Enabled'] then
                camera.CFrame = camera.CFrame:Lerp(Main, getgenv().Elysian['Camlock']['Smoothing']['Value'])
            else
                camera.CFrame = Main
            end
        end
    end
end)
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "BallWare (Da strike)",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/DHBCommunity/DHBOfficialScript/refs/heads/main/Protected_4021809531880627.txt"))()
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "BallWare (Works in some games)",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/DHBCommunity/DHBOfficialScript/main/FinallyV4"))()
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "Frost Exploits",
   Callback = function()
   --[[


██╗░░░░░███████╗░█████╗░██╗░░██╗███████╗██████╗░  ██████╗░██╗░░░██╗
██║░░░░░██╔════╝██╔══██╗██║░██╔╝██╔════╝██╔══██╗  ██╔══██╗╚██╗░██╔╝
██║░░░░░█████╗░░███████║█████═╝░█████╗░░██║░░██║  ██████╦╝░╚████╔╝░
██║░░░░░██╔══╝░░██╔══██║██╔═██╗░██╔══╝░░██║░░██║  ██╔══██╗░░╚██╔╝░░
███████╗███████╗██║░░██║██║░╚██╗███████╗██████╔╝  ██████╦╝░░░██║░░░
╚══════╝╚══════╝╚═╝░░╚═╝╚═╝░░╚═╝╚══════╝╚═════╝░  ╚═════╝░░░░╚═╝░░░

██╗░░██╗██╗░░██╗░█████╗░██╗░░██╗███████╗██████╗░
██║░░██║╚██╗██╔╝██╔══██╗██║░██╔╝██╔════╝██╔══██╗
███████║░╚███╔╝░██║░░╚═╝█████═╝░█████╗░░██████╔╝
██╔══██║░██╔██╗░██║░░██╗██╔═██╗░██╔══╝░░██╔══██╗
██║░░██║██╔╝╚██╗╚█████╔╝██║░╚██╗███████╗██║░░██║
╚═╝░░╚═╝╚═╝░░╚═╝░╚════╝░╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝ 

--]]



for Key, Object in pairs(getgc(true)) do
    if type(Object) == "table" then
        setreadonly(Object, false)
        local indexInstance = rawget(Object, "indexInstance")
        if type(indexInstance) == "table" and indexInstance[1] == "kick" then
            setreadonly(indexInstance, false)
            rawset(Object, "Table", {"kick", function() coroutine.yield() end})
            break
        end
    end
end

local Tool = Instance.new("Tool")
Tool.RequiresHandle = false
Tool.Name = "Lock Tool"
Tool.Parent = game.Players.LocalPlayer.Backpack

local player = game.Players.LocalPlayer

local function connectCharacterAdded()
    player.CharacterAdded:Connect(onCharacterAdded)
end

connectCharacterAdded()

player.CharacterRemoving:Connect(
    function()
        Tool.Parent = game.Players.LocalPlayer.Backpack
    end
)
local MainColor = Color3.fromRGB(173, 216, 230);
getgenv().Configurations = {
    Target = {
        Enabled = true,
        Prediction = 0.1356785,
        AutoPrediction = false,
        AimPart = "HumanoidRootPart",
        AutoArmor = false,
        Notify = true,
        AirPartEnabled = false,
        AirPart = "Head",
        LookAt = false,
        Spectate = false,
        AutoAir = false,
        CameraLock = {
            Enabled = false,
            UseShake = false,
            Shake = 3,
            Smoothness = false,
            SmoothnessAmount = 0.1,
            Style = "Elastic",
            Direction = "InOut"
        },
        HitPart = {
            Part = "HumanoidRootPart",
            ClosestPart = false,
            Mode = "Nearest Part" -- Options: Nearest Point, Part
        },
        FOV = {
            Show = false,
            Size = 100
        },
        Checks = {
            Enabled = false,
            Knocked = false,
            Grabbed = false,
            AntiGroundShots = true
        }
    },
    TriggerBot = {
        Enabled = false,
        Visualize = false,
        Prediction = 0.135,
        Range = 20,
        UseDelay = false,
        Delay = 0.02
    },
    Resolver = {
        Enabled = true,
        Method = "Recalculate", -- Options: LookVector, Recalculate, Zero Prediction, Move Direction
        AntiAimViewer = false
    },
    Misc = {
        CSync = {
            Enabled = false,
            VoidSpam = false,
            DestroyCheaters = false,
            Attach = true,
            Type = "Random",
            Visualize = {
                Enabled = true,
                Type = "Dot",
                Color = MainColor,
            },
            Randomize = {
                Value = 20,
            },
            Custom = {
                X = 0,
                Y = 0,
                Z = 0,
            },
            CFrameSpeed = {
              Enabled = false,
              Speed = 1,
            },
            AutoBuy = {
                SelectedFood = "Taco",
                SelectedGun = "LMG",
            }
        },
        TargetStrafe = {
            Enabled = false,
            CSync = true,
            Type = "Randomize",
            Randomization = 3,
            Speed = 10,
            Distance = 5,
            Height = 5,
            BypassDC = false
        },
        Animation = {
            Enabled = false,
            Speed = 1,
            SelectedDance = "Floss"
        }
    },
    Visuals = {
        World = {
            Enabled = false,
            Fog = {
                Enabled = false,
                Color = Color3.new(1, 1, 1),
                End = 1000,
                Start = 10000
            },
            Ambient = {
                Enabled = false,
                Color = Color3.new(1, 1, 1)
            },
            Brightness = {
                Enabled = false,
                Value = 0
            },
            ClockTime = {
                Enabled = false,
                Value = 24
            },
            WorldExposure = {
                Enabled = false,
                Value = -0.1
            }
        },
        Bullet_Trails = {
            Enabled = false,
            Width = 1.7,
            Duration = 5,
            Fade = false,
            FadeDuration = 5,
            Color = MainColor,
            Texture = "Normal" -- 12781803086
        },
        Bullet_Impacts = {
            Enabled = false,
            Width = 0.25,
            Color = MainColor,
            Duration = 5,
            Fade = false,
            FadeDuration = 5
        },
        Hit_Detection = {
            Enabled = false,
            Notify = true,
            Clone = false,
            HitEffect = false,
            HitEffectType = "Crescent Slash",
            Sound = false,
            HitSound = "Rust"
        },
        HighLight = {
            Enabled = true,
            Fill = MainColor,
            OutLine = Color3.fromRGB(255, 255, 255)
        },
        Line = {
            Enabled = true,
            Color = MainColor,
            Thickness = 2
        },
        Dot = {
            Enabled = false,
            Color = MainColor,
            Size = 0.5
        },
        BackTrack = {
            Enabled = false,
            Color = MainColor,
            ApplyTo = "Local Player",
            Duration = 0.1,
            Transparency = 0.5
        },
    }
}
local Notifications = {};
local Utility = {};
local Desync = {}
--
local Script = {
    Locals = {
        Angle = 0,
        Target = nil,
        AimAssistTarget = nil,
        HitPart = nil,
        AimAssistHitPart = nil,
        AimPoint = nil,
        AimAssistAimPoint = nil,
        Position = nil
    },
    Textures = {
        Normal = "rbxassetid://7151778302",
        Fog = "rbxassetid://9150635648"
    },
    World = {
        FogColor = game:GetService("Lighting").FogColor,
        FogStart = game:GetService("Lighting").FogStart,
        FogEnd = game:GetService("Lighting").FogEnd,
        Ambient = game:GetService("Lighting").Ambient,
        Brightness = game:GetService("Lighting").Brightness,
        ClockTime = game:GetService("Lighting").ClockTime,
        ExposureCompensation = game:GetService("Lighting").ExposureCompensation
    },
    HitSounds = {
        Bameware = "rbxassetid://3124331820",
        Bell = "rbxassetid://6534947240",
        Bubble = "rbxassetid://6534947588",
        Pick = "rbxassetid://1347140027",
        Pop = "rbxassetid://198598793",
        Rust = "rbxassetid://1255040462",
        Sans = "rbxassetid://3188795283",
        Fart = "rbxassetid://130833677",
        Big = "rbxassetid://5332005053",
        Vine = "rbxassetid://5332680810",
        Bruh = "rbxassetid://4578740568",
        Skeet = "rbxassetid://5633695679",
        Neverlose = "rbxassetid://6534948092",
        Fatality = "rbxassetid://6534947869",
        Bonk = "rbxassetid://5766898159",
        Minecraft = "rbxassetid://4018616850"
    },
    Guns = {
        "Revolver",
        "Double-Barrel SG",
        "High-Medium Armor",
        "Flamethrower",
        "SMG",
        "RPG",
        "P90",
        "LMG",
        "Key"
    },
    Food = {
        "Pizza",
        "Taco",
        "Chicken",
        "Cranberry",
        "Popcorn",
        "Hamburger",
        "HotDog"
    }
}

local Guns = {
   "Revolver",
   "Double-Barrel SG",
   "High-Medium Armor",
   "Flamethrower",
   "SMG",
   "RPG",
   "P90",
   "LMG",
   "Key" 
}

local Food = {
   "Pizza",
   "Taco",
   "Chicken",
   "Cranberry",
   "Popcorn",
   "Hamburger",
   "HotDog",
 }

--
--
local game_support = {
    { Number = 1, Name = "Da Hood", Argument = real_dh_arg or "UpdateMousePosI", BulletName = "BULLET_RAYS", BulletBeamName = "GunBeam", BulletPath = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Siren") and workspace.Ignored.Siren:FindFirstChild("Radius") or nil },
    { Number = 2, Name = "Locker Hood", Argument = "UpdateMousePos", BulletName = "BULLET_RAYS", BulletBeamName = "GunBeam", BulletPath = workspace:FindFirstChild("Ignored") or nil },
    { Number = 3, Name = "Hood Modded", Argument = "MousePos", BulletName = "BULLET_RAYS", BulletBeamName = "GunBeam", BulletPath = workspace:FindFirstChild("Ignored") or nil },
    { Number = 4, Name = "Da Downhill", Argument = "MOUSE", BulletName = "Part", BulletBeamName = "gb", BulletPath = workspace },
    { Number = 5, Name = "Da Bank", Argument = "MOUSE", BulletName = "Part", BulletBeamName = "gb", BulletPath = workspace },
    { Number = 6, Name = "Da Uphill", Argument = "MOUSE", BulletName = "Part", BulletBeamName = "gb", BulletPath = workspace },
    { Number = 7, Name = "Da Strike", Argument = "MOUSE", BulletName = "Part", BulletBeamName = "gb", BulletPath = workspace },
    { Number = 8, Name = "1v1 Hood Aim Trainer", Argument = "UpdateMousePos" },
    { Number = 9, Name = "Hood Aim", Argument = "MOUSE" },
    { Number = 10, Name = "Moon Hood", Argument = "MoonUpdateMousePos" },
    { Number = 11, Name = "OG Da Hood", Argument = "UpdateMousePos", Adonis = true },
    { Number = 12, Name = "Da Hood Macro", Argument = "UpdateMousePos1" },
    { Number = 13, Name = "Da Hood VC", Argument = real_dh_arg or "UpdateMousePosI", BulletName = "BULLET_RAYS", BulletBeamName = "GunBeam", BulletPath = workspace:FindFirstChild("Ignored") and workspace.Ignored:FindFirstChild("Siren") and workspace.Ignored.Siren:FindFirstChild("Radius") or nil },
    { Number = 15, Name = "Hood Customs", Argument = real_dh_arg or "MousePosUpdate", BulletName = "BULLET_RAYS", BulletBeamName = "GunBeam", BulletPath = workspace:FindFirstChild("Ignored") or nil },
    { Number = 16, Name = "Hood Z", Argument = "UpdateMousePos", BulletName = "bulletray", BulletBeamName = "beam", BulletPath = workspace:FindFirstChild("Ignored") or nil },
    { Number = 17, Name = "Custom FFA", Argument = "UpdateMousePos", BulletName = "BULLET_RAYS", BulletBeamName = "GunBeam", BulletPath = workspace:FindFirstChild("Ignored") or nil },
    { Number = 18, Name = "Yeno Hood", Argument = "UpdateMousePos", BulletName = "BULLET_RAYS", BulletBeamName = "GunBeam", BulletPath = workspace:FindFirstChild("Ignored") or nil },
}

local connections = {}
if not LPH_OBFUSCATED then
    LPH_JIT = function(...) return ... end
    LPH_JIT_MAX = function(...) return ... end
    LPH_JIT_ULTRA = function(...) return ... end
    LPH_NO_VIRTUALIZE = function(...) return ... end
    LPH_NO_UPVALUES = function(f) return function(...) return f(...) end end
    LPH_ENCSTR = function(...) return ... end
    LPH_STRENC = function(...) return ... end
    LPH_HOOK_FIX = function(...) return ... end
    LPH_CRASH = function() return print(debug.traceback()) end
end

local wrap = LPH_NO_VIRTUALIZE(function(f)
    coroutine.resume(coroutine.create(f))
end)

local mouse_argument, bullet_beam_name, bullet_name, bullet_path

for _, support in ipairs(game_support) do
    bullet_beam_name = support.BulletBeamName
    bullet_name = support.BulletName
    bullet_path = support.BulletPath
    mouse_argument = support.Argument

    if bullet_name and bullet_beam_name and bullet_path then
        if bullet_path then
            bullet_path = bullet_path
            break
        end
    end
end


local Players           = game:GetService("Players");
local RunService        = game:GetService("RunService");
local UserInputService  = game:GetService("UserInputService");
local ReplicatedStorage = game:GetService("ReplicatedStorage");
local Workspace         = game:GetService("Workspace");
local TweenService      = game:GetService("TweenService");
local Configurations    = getgenv().Configurations -- you can just do Configurations but i defined it since i dont want that yellow indicator on my roblox lsp
local Debris            = game:GetService('Debris');
local Lighting       = game:GetService("Lighting");

local LocalPlayer       = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()
local Drawing = Drawing.new
local crosshair_position = "Middle";
local clone_chams_tick = tick();
local is_targetting = false;
local old_hrp = nil;
local should_haalfi_destroy = false;
local Target = nil;
local Menu = loadstring(game:HttpGet("https://raw.githubusercontent.com/Hxckerskyy/frost.lol/refs/heads/main/uilib.lua"))()

-- // Crosshair Handler \\ --
local Cursor = loadstring(game:HttpGet('https://pastebin.com/raw/bG7mehvN', true))() do
    getgenv().crosshair.enabled = true
    getgenv().crosshair.color = MainColor
    getgenv().crosshair.mode = "Middle"
end

-- // Trigger Bot FOV \\ --
local TriggerBotFOV = Drawing("Circle")
TriggerBotFOV.Transparency = 1
TriggerBotFOV.Thickness = 1
TriggerBotFOV.Radius = Configurations.TriggerBot.Range
TriggerBotFOV.Filled = false
TriggerBotFOV.Color = Color3.fromRGB(204, 255, 255)
TriggerBotFOV.Visible = false

do -- Notification Library
    local NotificationContainer = Instance.new("ScreenGui", gethui())

    local function UpdateNotifications()
        local i = 0
        for v in next, Notifications do
            if v.Holder then
                Utility:Tween(v.Holder, TweenInfo.new(0.8, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2.new(0, 20, 0, 75 + (i * 25))})
                i = i + 1
            end
        end
    end

    local function UpdateNotifications2(Item)
        for _, v in pairs(Item) do
            if typeof(v) == "Instance" then
                task.spawn(function()
                    local tween = Utility:Tween(v, TweenInfo.new(1, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {BackgroundTransparency = 1})
                    tween.Completed:Connect(function()
                        if v.Name == "Holder" then v:Destroy() end
                    end)
                end)
                if v.ClassName == "TextLabel" then
                    Utility:Tween(v, TweenInfo.new(1, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {TextTransparency = 1})
                end
            end
        end
    end

    function Notifications:New(Text, Time, Color)
        Time = Time or 2
        Color = Color or Color3.fromRGB(173, 216, 230)
        Text = Text or "No text provided? "..tostring(math.random())

        local Notification = {}

        local Holder = Instance.new("Frame")
        Holder.Position = UDim2.new(0, -30, 0, 75)
        Holder.Size = UDim2.new(0, 0, 0, 23)
        Holder.BackgroundColor3 = Color3.fromRGB(37, 37, 37)
        Holder.BorderSizePixel = 1
        Holder.BorderColor3 = Color3.fromRGB(0, 0, 0)
        Holder.Parent = NotificationContainer
        Notification.Holder = Holder

        local Background = Instance.new("Frame")
        Background.Size = UDim2.new(1, -4, 1, -4)
        Background.Position = UDim2.new(0, 2, 0, 2)
        Background.BackgroundColor3 = Color3.fromRGB(17, 17, 17)
        Background.BorderSizePixel = 1
        Background.BorderColor3 = Color3.fromRGB(0, 0, 0)
        Background.Parent = Holder
        Notification.Background = Background

        local AccentBar = Instance.new("Frame")
        AccentBar.Size = UDim2.new(0, 1, 1, 0)
        AccentBar.BackgroundColor3 = Color
        AccentBar.Parent = Background
        Notification.AccentBar = AccentBar

        local AccentBar2 = Instance.new("Frame")
        AccentBar2.Size = UDim2.new(0, 0, 0, 1)
        AccentBar2.Position = UDim2.new(0, 0, 0, 15)
        AccentBar2.BackgroundColor3 = Color
        AccentBar2.Parent = Background
        Notification.AccentBar2 = AccentBar2

        local NotifText = Instance.new("TextLabel")
        NotifText.TextXAlignment = Enum.TextXAlignment.Left
        NotifText.Position = UDim2.new(0, 3, 0, 0)
        NotifText.Size = UDim2.new(1, 0, 1, 0)
        NotifText.Font = Enum.Font.Ubuntu
        NotifText.TextColor3 = Color3.new(1, 1, 1)
        NotifText.BackgroundTransparency = 1
        NotifText.TextSize = 12
        NotifText.Text = Text
        NotifText.Parent = Background
        Notification.NotifText = NotifText

        Holder.Size = UDim2.new(0, NotifText.TextBounds.X + 10, 0, 19)
        AccentBar2.Size = UDim2.new(0, 1, 0, 1)

        Notifications[Notification] = true

        task.spawn(function()
            Holder.Size = UDim2.new(0, NotifText.TextBounds.X + 10, 0, 19)
            UpdateNotifications()
            AccentBar2:TweenSize(UDim2.new(0, Background.AbsoluteSize.X - 1, 0, 1), Enum.EasingDirection.Out, Enum.EasingStyle.Linear, Time, false)
            task.wait(Time)
            UpdateNotifications2(Notification)
            task.wait(1.2)
            Notifications[Notification] = nil
            UpdateNotifications()
        end)
    end

    function Utility:Tween(...)
        local NewTween = game:GetService("TweenService"):Create(...)
        NewTween:Play()
        return NewTween
    end
end
--
-- // math
local custom_math = {}; do
   custom_math.get_auto_prediction = LPH_NO_VIRTUALIZE(function()
        local PingStats = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local Value = tostring(PingStats)
        local PingValue = Value:split(" ")
        local PingNumber = tonumber(PingValue[1])
        
        return tonumber(PingNumber / 1000 + 0.037)
        end)
   
   custom_math.random_vector3 = LPH_NO_VIRTUALIZE(function(randomization)
		return Vector3.new(math.random(-randomization, randomization), math.random(-randomization, randomization), math.random(-randomization, randomization));
	end);
	
   custom_math.recalculate_velocity = LPH_NO_VIRTUALIZE(function(player)
        local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
        local initialPosition = rootPart.Position
        local initialTime = tick()

        task.wait()

        local finalPosition = rootPart.Position
        local finalTime = tick()

        local distanceTraveled = finalPosition - initialPosition
        local timeInterval = finalTime - initialTime
        return distanceTraveled / timeInterval
    end)
end

-- // utility
local utility = {}; do
   utility.world_to_screen = LPH_NO_VIRTUALIZE(function(position)
		local position, on_screen = Camera:WorldToViewportPoint(position);

		return {position = Vector2.new(position.X, position.Y), on_screen = on_screen};
	end);
	
	utility.has_character = LPH_NO_VIRTUALIZE(function(player)
		return (player and player.Character and player.Character:FindFirstChild("Humanoid")) and true or false;
	end);
	
	utility.new_connection = function(type, callback) --// by all matters do NOT no virtualize this
		local connection = type:Connect(callback);

		table.insert(connections, connection);

		return connection;
	end;

	utility.create_connection = function(signal_name) --// by all matters do NOT no virtualize this
		local connection = signal.new(signal_name);
		return connection;
	end;
	
	utility.drawing_new = function(type, properties)
		local drawing_object = Drawing(type);

		for property, value in properties do
			drawing_object[property] = value;
		end;

		return drawing_object;
	end;

	utility.instance_new = function(type, properties)
		local instance = Instance.new(type);

		for property, value in properties do
			instance[property] = value;
		end;

		return instance;
	end;
	
	utility.clone_character = function(player, transparency, color, material, delete_hrp)
		local delete_hrp = delete_hrp or true;

		player.Character.Archivable = true;
		local new_character = player.Character:Clone();
		new_character.Parent = workspace;
		player.Character.Archivable = false;
		
		local parts = new_character:GetChildren();
		
		for i = 1, #parts do
			local part = parts[i];
				
			if (part.ClassName == "MeshPart") then
				part.Anchored = true;
				part.CanCollide = false;
				part.Color = color;
				part.Material = Enum.Material[material];
				part.Transparency = transparency;
			else
				if part.Name ~= "HumanoidRootPart" and delete_hrp then
					part:Destroy();
				end;
			end;
			
			if part.Name == "Head" then
				local decal = part:FindFirstChild("face");
				
				if decal then decal:Destroy() end;
			end;
		end;

		return new_character;
	end;

	utility.create_beam = LPH_NO_VIRTUALIZE(function(from, to, color_1, color_2, duration, fade_enabled, fade_duration)
		local tween;
		local total_time = 0;

		local main_part = utility.instance_new("Part", {
			Parent = workspace,
			Size = Vector3.new(0, 0, 0),
			Massless = true,
			Transparency = 1,
			CanCollide = false,
			Position = from,
			Anchored = true
		});

		local part0 = utility.instance_new("Part", {
			Parent = main_part,
			Size = Vector3.new(0, 0, 0),
			Massless = true,
			Transparency = 1,
			CanCollide = false,
			Position = from,
			Anchored = true
		});

		local part1 = utility.instance_new("Part", {
			Parent = main_part,
			Size = Vector3.new(0, 0, 0),
			Massless = true,
			Transparency = 1,
			CanCollide = false,
			Position = to,
			Anchored = true
		});

		local attachment0 = utility.instance_new("Attachment", {
			Parent = part0
		});

		local attachment1 = utility.instance_new("Attachment", {
			Parent = part1
		});

		local beam = utility.instance_new("Beam", {
			Texture = "rbxassetid://446111271",
			TextureMode = Enum.TextureMode.Wrap,
			TextureLength = 10,
			LightEmission = 1,
			LightInfluence = 1,
			FaceCamera = true,
			ZOffset = -1,
			Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(1, 1),
			}),
			Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, color_1),
				ColorSequenceKeypoint.new(1, color_2),
			}),
			Attachment0 = attachment0,
			Attachment1 = attachment1,
			Enabled = true,
			Parent = main_part
		});


		if fade_enabled then
			tween = utility.new_connection(RunService.Heartbeat, function(delta_time) --// credits to xander
				total_time += delta_time;
				beam.Transparency = NumberSequence.new(TweenService:GetValue((total_time / fade_duration), Enum.EasingStyle.Quad, Enum.EasingDirection.In));
			end)
		end;

		task.delay(duration, function()
			main_part:Destroy();

			if (tween) then
				tween:Disconnect();
			end;
		end);
	end);

	utility.create_impact = function(color, size, fade_enabled, fade_duration, duration, position)
		local impact = utility.instance_new("Part", {
			CanCollide = false;
			Material = Enum.Material.Neon;
			Size = Vector3.new(size, size, size);
			Color = color;
			Position = position;
			Anchored = true;
			Parent = workspace
		});

		local outline = utility.instance_new("SelectionBox", { --// credits to xander
			LineThickness = 0.01;
			Color3 = color;
			SurfaceTransparency = 1;
			Adornee = impact;
			Visible = true;
			Parent = impact
		});

		if (fade_enabled) then
			local tween_info = TweenInfo.new(duration);
			local tween = TweenService:Create(impact, tween_info, {Transparency = 1});
			local tween_outline = TweenService:Create(outline, tween_info, {Transparency = 1});

			tween:Play();
			tween_outline:Play();
		end;

		task.delay(duration, function()
			impact:Destroy()		
		end);
	end;
end

--// hit effects
local hit_effects = {}; do
hit_effects.slash = function(position)
	local part = utility.instance_new("Part", {
		Position = position,
		Anchored = true,
		Transparency = 1,
		CanCollide = false,
		Parent = workspace
	})

	local particleEmitters = {
		{ -- Crescents
			Name = "Crescents",
			Lifetime = NumberRange.new(0.19, 0.38),
			SpreadAngle = Vector2.new(-360, 360),
			Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 1),
				NumberSequenceKeypoint.new(0.1932907, 0),
				NumberSequenceKeypoint.new(0.778754, 0),
				NumberSequenceKeypoint.new(1, 1)
			}),
			LightEmission = 10,
			Color = ColorSequence.new({
				ColorSequenceKeypoint.new(0, MainColor),
				ColorSequenceKeypoint.new(0.3160622, MainColor),
				ColorSequenceKeypoint.new(0.5146805, MainColor),
				ColorSequenceKeypoint.new(1, MainColor)
			}),
			VelocitySpread = -360,
			Speed = NumberRange.new(0.0826858, 0.0826858),
			Brightness = 4,
			Size = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(0.398774, 8.8026266, 2.2834616),
				NumberSequenceKeypoint.new(1, 11.477972, 1.860431)
			}),
			ZOffset = 0.4542207,
			Rate = 50,
			Texture = "rbxassetid://12509373457",
			Rotation = NumberRange.new(-360, 360),
			Orientation = Enum.ParticleOrientation.VelocityPerpendicular
		}
	}

	for _, emitterProperties in ipairs(particleEmitters) do
		local emitter = utility.instance_new("ParticleEmitter", emitterProperties)
		emitter.Parent = part
		emitter:Emit()
	end

	task.delay(1, function()
		part:Destroy()
	end)
end

hit_effects.cum = function(position)
    local part = utility.instance_new("Part", {
        Position = position,
        Anchored = true,
        Transparency = 1,
        CanCollide = false,
        Parent = workspace
    })

    local attachment = utility.instance_new("Attachment", {
        Parent = part
    })

    local foam = utility.instance_new("ParticleEmitter", {
        Name = "Foam",
        LightInfluence = 0.5,
        Lifetime = NumberRange.new(1, 1),
        SpreadAngle = Vector2.new(360, -360),
        VelocitySpread = 360,
        Squash = NumberSequence.new(1),
        Speed = NumberRange.new(20, 20),
        Brightness = 2.5,
        Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0),
            NumberSequenceKeypoint.new(0.1016692, 0.6508875, 0.6508875),
            NumberSequenceKeypoint.new(0.6494689, 1.4201183, 0.4127519),
            NumberSequenceKeypoint.new(1, 0)
        }),
        Enabled = false,
        Acceleration = Vector3.new(0, -66.04029846191406, 0),
        Rate = 100,
        Texture = "rbxassetid://8297030850",
        Rotation = NumberRange.new(-90, -90),
        Orientation = Enum.ParticleOrientation.VelocityParallel,
        Parent = attachment
    })

    foam:Emit()

    task.delay(1, function()
        part:Destroy()
    end)
end

hit_effects.atomic_slash = function(position)
	local part = utility.instance_new("Part", {
		Position = position,
		Anchored = true,
		Transparency = 1,
		CanCollide = false,
		Parent = workspace
	})

	local particleEmitters = {
		{ -- Crescents
			Name = "Crescents",
			Lifetime = NumberRange.new(0.19, 0.38),
			SpreadAngle = Vector2.new(-360, 360),
			Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 1),
				NumberSequenceKeypoint.new(0.1932907, 0),
				NumberSequenceKeypoint.new(0.778754, 0),
				NumberSequenceKeypoint.new(1, 1)
			}),
			LightEmission = 10,
			Color = ColorSequence.new(Color3.fromRGB(160, 96, 255)),
			VelocitySpread = -360,
			Speed = NumberRange.new(0.0826858, 0.0826858),
			Brightness = 4,
			Size = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(0.398774, 8.8026266, 2.2834616),
				NumberSequenceKeypoint.new(1, 11.477972, 1.860431)
			}),
			ZOffset = 0.4542207,
			Rate = 50,
			Texture = "rbxassetid://12509373457",
			Rotation = NumberRange.new(-360, 360),
			Orientation = Enum.ParticleOrientation.VelocityPerpendicular
		},
		{ -- Glow
			Name = "Glow",
			Lifetime = NumberRange.new(0.16, 0.16),
			Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 1),
				NumberSequenceKeypoint.new(0.1421725, 0.6182796),
				NumberSequenceKeypoint.new(1, 1)
			}),
			Color = ColorSequence.new(Color3.fromRGB(173, 82, 252)),
			Speed = NumberRange.new(0, 0),
			Brightness = 5,
			Size = NumberSequence.new(9.1873131, 16.5032349),
			ZOffset = -0.0565939,
			Rate = 50,
			Texture = "rbxassetid://8708637750"
		},
		{ -- Effect
			Name = "Effect",
			Lifetime = NumberRange.new(0.4, 0.7),
			FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4,
			SpreadAngle = Vector2.new(360, -360),
			LockedToPart = true,
			Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 1),
				NumberSequenceKeypoint.new(0.1070999, 0.19375),
				NumberSequenceKeypoint.new(0.7761194, 0.88125),
				NumberSequenceKeypoint.new(1, 1)
			}),
			LightEmission = 1,
			Color = ColorSequence.new(Color3.fromRGB(173, 82, 252)),
			Drag = 1,
			VelocitySpread = 360,
			Speed = NumberRange.new(0.0036749, 0.0036749),
			Brightness = 2.0999999,
			Size = NumberSequence.new(6.9680691, 9.9213123),
			ZOffset = 0.4777403,
			Rate = 50,
			Texture = "rbxassetid://9484012464",
			Rotation = NumberRange.new(50, 50),
			Orientation = Enum.ParticleOrientation.VelocityPerpendicular,
			FlipbookMode = Enum.ParticleFlipbookMode.OneShot
		},
		{ -- Gradient1
			Name = "Gradient1",
			Lifetime = NumberRange.new(0.3, 0.3),
			Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 1),
				NumberSequenceKeypoint.new(0.15, 0.3),
				NumberSequenceKeypoint.new(1, 1)
			}),
			Color = ColorSequence.new(Color3.fromRGB(173, 82, 252)),
			Speed = NumberRange.new(0, 0),
			Brightness = 6,
			Size = NumberSequence.new(0, 11.6261358),
			ZOffset = 0.9187313,
			Rate = 50,
			Texture = "rbxassetid://8196169974"
		},
		{ -- Shards
			Name = "Shards",
			Lifetime = NumberRange.new(0.19, 0.7),
			SpreadAngle = Vector2.new(-90, 90),
			Color = ColorSequence.new(Color3.fromRGB(179, 145, 253)),
			Drag = 10,
			VelocitySpread = -90,
			Squash = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 1),
				NumberSequenceKeypoint.new(0.5705521, 0.4125001),
				NumberSequenceKeypoint.new(1, -0.9375)
			}),
			Speed = NumberRange.new(97.7530136, 146.9970093),
			Brightness = 4,
			Size = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(0.284774, 1.2389833, 0.1534118),
				NumberSequenceKeypoint.new(1, 0)
			}),
			Acceleration = Vector3.new(0, -56.961341857910156, 0),
			ZOffset = 0.5705321,
			Rate = 50,
			Texture = "rbxassetid://8030734851",
			Rotation = NumberRange.new(90, 90),
			Orientation = Enum.ParticleOrientation.VelocityParallel
		}
	}

	for _, emitterProperties in ipairs(particleEmitters) do
		local emitter = utility.instance_new("ParticleEmitter", emitterProperties)
		emitter.Parent = part
		emitter:Emit()
	end

	task.delay(1, function()
		part:Destroy()
	end)
end

hit_effects.cosmic_explosion = function(position)
	local part = utility.instance_new("Part", {
		Position = position,
		Anchored = true,
		Transparency = 1,
		CanCollide = false,
		Parent = workspace
	})

	local particleEmitters = {
		{ -- Glow
			Name = "Glow",
			Lifetime = NumberRange.new(0.16, 0.16),
			Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1421725, 0.6182796), NumberSequenceKeypoint.new(1, 1)}),
			Color = ColorSequence.new(Color3.fromRGB(173, 82, 252)),
			Speed = NumberRange.new(0, 0),
			Brightness = 5,
			Size = NumberSequence.new(9.1873131, 16.5032349),
			ZOffset = -0.0565939,
			Rate = 50,
			Texture = "rbxassetid://8708637750"
		},
		{ -- Effect
			Name = "Effect",
			Lifetime = NumberRange.new(0.4, 0.7),
			FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4,
			SpreadAngle = Vector2.new(360, -360),
			LockedToPart = true,
			Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1070999, 0.19375), NumberSequenceKeypoint.new(0.7761194, 0.88125), NumberSequenceKeypoint.new(1, 1)}),
			LightEmission = 1,
			Color = ColorSequence.new(Color3.fromRGB(173, 82, 252)),
			Drag = 1,
			VelocitySpread = 360,
			Speed = NumberRange.new(0.0036749, 0.0036749),
			Brightness = 2.0999999,
			Size = NumberSequence.new(6.9680691, 9.9213123),
			ZOffset = 0.4777403,
			Rate = 50,
			Texture = "rbxassetid://9484012464",
			RotSpeed = NumberRange.new(-150, -150),
			FlipbookMode = Enum.ParticleFlipbookMode.OneShot,
			Rotation = NumberRange.new(50, 50),
			Orientation = Enum.ParticleOrientation.VelocityPerpendicular
		},
		{ -- Gradient1
			Name = "Gradient1",
			Lifetime = NumberRange.new(0.3, 0.3),
			Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.15, 0.3), NumberSequenceKeypoint.new(1, 1)}),
			Color = ColorSequence.new(Color3.fromRGB(173, 82, 252)),
			Speed = NumberRange.new(0, 0),
			Brightness = 6,
			Size = NumberSequence.new(0, 11.6261358),
			ZOffset = 0.9187313,
			Rate = 50,
			Texture = "rbxassetid://8196169974"
		},
		{ -- Shards
			Name = "Shards",
			Lifetime = NumberRange.new(0.19, 0.7),
			SpreadAngle = Vector2.new(-90, 90),
			Color = ColorSequence.new(Color3.fromRGB(173, 82, 252)),
			Drag = 10,
			VelocitySpread = -90,
			Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5705521, 0.4125001), NumberSequenceKeypoint.new(1, -0.9375)}),
			Speed = NumberRange.new(97.7530136, 146.9970093),
			Brightness = 4,
			Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.284774, 1.2389833, 0.1534118), NumberSequenceKeypoint.new(1, 0)}),
			Enabled = false,
			Acceleration = Vector3.new(0, -56.961341857910156, 0),
			ZOffset = 0.5705321,
			Rate = 50,
			Texture = "rbxassetid://8030734851",
			Rotation = NumberRange.new(90, 90),
			Orientation = Enum.ParticleOrientation.VelocityParallel
		},
		{ -- Crescents
			Name = "Crescents",
			Lifetime = NumberRange.new(0.19, 0.38),
			SpreadAngle = Vector2.new(-360, 360),
			Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1932907, 0), NumberSequenceKeypoint.new(0.778754, 0), NumberSequenceKeypoint.new(1, 1)}),
			LightEmission = 10,
			Color = ColorSequence.new(Color3.fromRGB(160, 96, 255)),
			VelocitySpread = -360,
			Speed = NumberRange.new(0.0826858, 0.0826858),
			Brightness = 4,
			Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.398774, 8.8026266, 2.2834616), NumberSequenceKeypoint.new(1, 11.477972, 1.860431)}),
			ZOffset = 0.4542207,
			Rate = 50,
			Texture = "rbxassetid://12509373457",
			Rotation = NumberRange.new(-360, 360),
			Orientation = Enum.ParticleOrientation.VelocityPerpendicular
		},
		{ -- ParticleEmitter2
			Name = "ParticleEmitter2",
			FlipbookFramerate = NumberRange.new(20, 20),
			Lifetime = NumberRange.new(0.19, 0.38),
			FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4,
			SpreadAngle = Vector2.new(360, 360),
			Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.209842, 0.5), NumberSequenceKeypoint.new(0.503842, 0.263333), NumberSequenceKeypoint.new(0.799842, 0.5), NumberSequenceKeypoint.new(1, 1)}),
			LightEmission = 1,
			Color = ColorSequence.new(Color3.fromRGB(173, 82, 252)),
			VelocitySpread = 360,
			Speed = NumberRange.new(0.0161231, 0.0161231),
			Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 4.3125), NumberSequenceKeypoint.new(0.3985056, 7.9375), NumberSequenceKeypoint.new(1, 10)}),
			ZOffset = 0.15,
			Rate = 100,
			Texture = "http://www.roblox.com/asset/?id=12394566430",
			FlipbookMode = Enum.ParticleFlipbookMode.OneShot,
			Rotation = NumberRange.new(39, 999),
			Orientation = Enum.ParticleOrientation.VelocityParallel
		}
	}

	for _, emitterProperties in ipairs(particleEmitters) do
		local emitter = utility.instance_new("ParticleEmitter", emitterProperties)
		emitter.Parent = part
		emitter:Emit()
	end

	task.delay(1, function()
		part:Destroy()
	end)
end

hit_effects.crescent_slash = function(position)
	local part = utility.instance_new("Part", {
		Position = position,
		Anchored = true,
		Transparency = 1,
		CanCollide = false,
		Parent = workspace
	})

	local particleEmitters = {
		{ -- Glow
			Name = "Glow",
			Lifetime = NumberRange.new(0.16, 0.16),
			Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.1421725, 0.6182796), NumberSequenceKeypoint.new(1, 1)}),
			Color = ColorSequence.new(Color3.fromRGB(91, 177, 252)),
			Speed = NumberRange.new(0, 0),
			Brightness = 5,
			Size = NumberSequence.new(9.1873131, 16.5032349),
			Enabled = false,
			ZOffset = -0.0565939,
			Rate = 50,
			Texture = "rbxassetid://8708637750"
		},
		{ -- Gradient1
			Name = "Gradient1",
			Lifetime = NumberRange.new(0.3, 0.3),
			Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.15, 0.3), NumberSequenceKeypoint.new(1, 1)}),
			Color = ColorSequence.new(Color3.fromRGB(115, 201, 255)),
			Speed = NumberRange.new(0, 0),
			Brightness = 6,
			Size = NumberSequence.new(0, 11.6261358),
			Enabled = false,
			ZOffset = 0.9187313,
			Rate = 50,
			Texture = "rbxassetid://8196169974"
		},
		{ -- Shards
			Name = "Shards",
			Lifetime = NumberRange.new(0.19, 0.7),
			SpreadAngle = Vector2.new(-90, 90),
			Color = ColorSequence.new(Color3.fromRGB(108, 184, 255)),
			Drag = 10,
			VelocitySpread = -90,
			Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5705521, 0.4125001), NumberSequenceKeypoint.new(1, -0.9375)}),
			Speed = NumberRange.new(97.7530136, 146.9970093),
			Brightness = 4,
			Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.284774, 1.2389833, 0.1534118), NumberSequenceKeypoint.new(1, 0)}),
			Enabled = false,
			Acceleration = Vector3.new(0, -56.961341857910156, 0),
			ZOffset = 0.5705321,
			Rate = 50,
			Texture = "rbxassetid://8030734851",
			Rotation = NumberRange.new(90, 90),
			Orientation = Enum.ParticleOrientation.VelocityParallel
		},
		{ -- ShardsDark
			Name = "ShardsDark",
			Lifetime = NumberRange.new(0.19, 0.35),
			SpreadAngle = Vector2.new(-90, 90),
			Color = ColorSequence.new(Color3.fromRGB(108, 184, 255)),
			Drag = 10,
			VelocitySpread = -90,
			Squash = NumberSequence.new({NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.5705521, 0.4125001), NumberSequenceKeypoint.new(1, -0.9375)}),
			Speed = NumberRange.new(97.7530136, 146.9970093),
			Brightness = 4,
			Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.290774, 0.6734411, 0.1534118), NumberSequenceKeypoint.new(1, 0)}),
			Enabled = false,
			ZOffset = 0.5705321,
			Rate = 50,
			Texture = "rbxassetid://8030734851",
			Rotation = NumberRange.new(90, 90),
			Orientation = Enum.ParticleOrientation.VelocityParallel
		},
		{ -- Specs
			Name = "Specs",
			Lifetime = NumberRange.new(0.33, 1.4),
			SpreadAngle = Vector2.new(360, -1000),
			Color = ColorSequence.new(Color3.fromRGB(98, 174, 255)),
			Drag = 10,
			VelocitySpread = 360,
			Speed = NumberRange.new(36.7492523, 146.9970093),
			Brightness = 7,
			Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.200774, 2.0311937, 0.4363973), NumberSequenceKeypoint.new(1, 0)}),
			Enabled = false,
			Acceleration = Vector3.new(0, 36.74925231933594, 0),
			Rate = 50,
			Texture = "rbxassetid://8030760338",
			EmissionDirection = Enum.NormalId.Right
		},
		{ -- Specs1
			Name = "Specs1",
			Lifetime = NumberRange.new(0.33, 1.75),
			SpreadAngle = Vector2.new(90, -90),
			Color = ColorSequence.new(Color3.fromRGB(106, 171, 255)),
			Drag = 9,
			VelocitySpread = 90,
			Speed = NumberRange.new(42.2616425, 73.4985046),
			Brightness = 6,
			Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.210774, 0.3978962, 0.1855686), NumberSequenceKeypoint.new(1, 0)}),
			Enabled = false,
			Acceleration = Vector3.new(0, -20.21208953857422, 0),
			ZOffset = 0.5144895,
			Rate = 50,
			Texture = "rbxassetid://8030760338"
		},
		{ -- Specs2
			Name = "Specs2",
			Lifetime = NumberRange.new(0.19, 1.2),
			SpreadAngle = Vector2.new(360, -1000),
			Color = ColorSequence.new(Color3.fromRGB(98, 174, 255)),
			Drag = 10,
			VelocitySpread = 360,
			Speed = NumberRange.new(36.7492523, 146.9970093),
			Brightness = 7,
			Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.200774, 2.0311937, 0.4363973), NumberSequenceKeypoint.new(1, 0)}),
			Enabled = false,
			Acceleration = Vector3.new(0, 36.74925231933594, 0),
			Rate = 50,
			Texture = "rbxassetid://8030760338",
			EmissionDirection = Enum.NormalId.Right
		},
		{ -- Specs21
			Name = "Specs21",
			Lifetime = NumberRange.new(0.19, 1.35),
			SpreadAngle = Vector2.new(90, -90),
			Color = ColorSequence.new(Color3.fromRGB(106, 171, 255)),
			Drag = 12,
			VelocitySpread = 90,
			Speed = NumberRange.new(42.2616425, 73.4985046),
			Brightness = 6,
			Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(0.216774, 0.5721694, 0.1855686), NumberSequenceKeypoint.new(1, 0)}),
			Enabled = false,
			Acceleration = Vector3.new(0, -20.21208953857422, 0),
			ZOffset = 0.5144895,
			Rate = 50,
			Texture = "rbxassetid://8030760338"
		},
		{ -- Crescents
			Name = "Crescents",
			Lifetime = NumberRange.new(0.19, 0.38),
			SpreadAngle = Vector2.new(-360, 360),
			Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 1),
				NumberSequenceKeypoint.new(0.1932907, 0),
				NumberSequenceKeypoint.new(0.778754, 0),
				NumberSequenceKeypoint.new(1, 1)
			}),
			LightEmission = 1,
			Color = ColorSequence.new(Color3.fromRGB(92, 161, 252)),
			VelocitySpread = -360,
			Speed = NumberRange.new(0.0826858, 0.0826858),
			Brightness = 20,
			Size = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(0.398774, 8.8026266, 2.2834616),
				NumberSequenceKeypoint.new(1, 11.477972, 1.860431)
			}),
			ZOffset = 0.4542207,
			Rate = 50,
			Texture = "rbxassetid://12509373457",
			RotSpeed = NumberRange.new(800, 1000),
			Rotation = NumberRange.new(-360, 360),
			Orientation = Enum.ParticleOrientation.VelocityPerpendicular
		},
		{ -- Effect
			Name = "Effect",
			Lifetime = NumberRange.new(0.4, 0.7),
			FlipbookLayout = Enum.ParticleFlipbookLayout.Grid4x4,
			SpreadAngle = Vector2.new(360, -360),
			LockedToPart = true,
			Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 1),
				NumberSequenceKeypoint.new(0.1070999, 0.19375),
				NumberSequenceKeypoint.new(0.7761194, 0.88125),
				NumberSequenceKeypoint.new(1, 1)
			}),
			LightEmission = 1,
			Color = ColorSequence.new(Color3.fromRGB(92, 161, 252)),
			Drag = 1,
			VelocitySpread = 360,
			Speed = NumberRange.new(0.0036749, 0.0036749),
			Brightness = 2.0999999,
			Size = NumberSequence.new(6.9680691, 9.9213123),
			ZOffset = 0.4777403,
			Rate = 50,
			Texture = "rbxassetid://9484012464",
			RotSpeed = NumberRange.new(-150, -150),
			Rotation = NumberRange.new(50, 50),
			Orientation = Enum.ParticleOrientation.VelocityPerpendicular
		},
		{ -- out_Specs
			Name = "out_Specs",
			Lifetime = NumberRange.new(0.19, 1),
			SpreadAngle = Vector2.new(44, -1000),
			Color = ColorSequence.new(Color3.fromRGB(98, 174, 255)),
			Drag = 10,
			VelocitySpread = 44,
			Speed = NumberRange.new(36.7492523, 146.9970093),
			Brightness = 7,
			Size = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(0.244774, 0.5469525, 0.1433053),
				NumberSequenceKeypoint.new(1, 0)
			}),
			Acceleration = Vector3.new(0, -3.215559720993042, 0),
			Rate = 50,
			Texture = "rbxassetid://8030760338",
			EmissionDirection = Enum.NormalId.Right
		},
		{ -- large_shard
			Name = "large_shard",
			Lifetime = NumberRange.new(0.19, 0.28),
			SpreadAngle = Vector2.new(-90, 90),
			Color = ColorSequence.new(Color3.fromRGB(108, 184, 255)),
			Drag = 10,
			VelocitySpread = -90,
			Squash = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 1),
				NumberSequenceKeypoint.new(0.5705521, 0.4125001),
				NumberSequenceKeypoint.new(1, -0.9375)
			}),
			Speed = NumberRange.new(97.7530136, 146.9970093),
			Brightness = 4,
			Size = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(0.260774, 3.515605, 0.1534118),
				NumberSequenceKeypoint.new(1, 0)
			}),
			ZOffset = 0.5705321,
			Rate = 50,
			Texture = "rbxassetid://8030734851",
			Rotation = NumberRange.new(90, 90),
			Orientation = Enum.ParticleOrientation.VelocityParallel
		},
		{ -- ddddddddddddddddddd
			Name = "ddddddddddddddddddd",
			Lifetime = NumberRange.new(0.19, 0.37),
			SpreadAngle = Vector2.new(90, -90),
			LockedToPart = true,
			Transparency = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(0.6429392, 0),
				NumberSequenceKeypoint.new(1, 0)
			}),
			LightEmission = 1,
			Color = ColorSequence.new(Color3.fromRGB(90, 184, 255), Color3.fromRGB(165, 251, 255)),
			Drag = 6,
			TimeScale = 0.7,
			VelocitySpread = 90,
			Speed = NumberRange.new(81.5833435, 110.2477646),
			Size = NumberSequence.new({
				NumberSequenceKeypoint.new(0, 0),
				NumberSequenceKeypoint.new(0.410774, 0.6711507, 0.3356177),
				NumberSequenceKeypoint.new(1, 0)
			}),
			Enabled = false,
			Acceleration = Vector3.new(0, -81.58334350585938, 0),
			ZOffset = 0.8345273,
			Rate = 50,
			Texture = "rbxassetid://1053546634",
			RotSpeed = NumberRange.new(-444, 166),
			Rotation = NumberRange.new(-360, 360)
		},
	}

	local attachment = Instance.new("Attachment")
	attachment.Name = "Attachment"
	attachment.Parent = part

	for _, emitterSettings in ipairs(particleEmitters) do
		local emitter = Instance.new("ParticleEmitter")
		for key, value in pairs(emitterSettings) do
			emitter[key] = value
		end
		emitter.Parent = attachment
	end

	local emitters = part:GetChildren()
	for _, emitter in ipairs(emitters) do
		if emitter:IsA("ParticleEmitter") then
			emitter:Emit()
		end
	end

	task.delay(1, function()
		part:Destroy()
	end)
end



	hit_effects.confetti = function(position) --// credits to xander
		local part = utility.instance_new("Part", {
			Position = position,
			Anchored = true,
			Transparency = 1,
			CanCollide = false,
			Parent = workspace
		});

		for i = 1, 5 do
			local particle1 = utility.instance_new("ParticleEmitter", {
				Acceleration = Vector3.new(0,-10,0);
				Color = ColorSequence.new{ColorSequenceKeypoint.new(0,Color3.new(0,1,0.886275)),ColorSequenceKeypoint.new(1,Color3.new(0,1,0.886275))};
				Lifetime = NumberRange.new(1,2);
				Rate = 0;
				RotSpeed = NumberRange.new(260,260);
				Size = NumberSequence.new{NumberSequenceKeypoint.new(0,0.1,0),NumberSequenceKeypoint.new(1,0.1,0)};
				Speed = NumberRange.new(15,15);
				SpreadAngle = Vector2.new(360,360);
				Texture = "http://www.roblox.com/asset/?id=241685484";
				Parent = part
			});
			local particle2 = utility.instance_new("ParticleEmitter", {
				Acceleration = Vector3.new(0,-10,0);
				Color = ColorSequence.new{ColorSequenceKeypoint.new(0,Color3.new(0,0.0980392,1)),ColorSequenceKeypoint.new(1,Color3.new(0,0,1))};
				Lifetime = NumberRange.new(1,2);
				Rate = 0;
				RotSpeed = NumberRange.new(260,260);
				Size = NumberSequence.new{NumberSequenceKeypoint.new(0,0.1,0),NumberSequenceKeypoint.new(1,0.1,0)};
				Speed = NumberRange.new(15,15);
				SpreadAngle = Vector2.new(360,360);
				Texture = "http://www.roblox.com/asset/?id=241685484]";
				Parent = part
			});
			local particle3 = utility.instance_new("ParticleEmitter", {
				Acceleration = Vector3.new(0,-10,0);
				Color = ColorSequence.new{ColorSequenceKeypoint.new(0,Color3.new(0.901961,1,0)),ColorSequenceKeypoint.new(1,Color3.new(1,0.933333,0))};
				Lifetime = NumberRange.new(1,2);
				Rate = 0;
				RotSpeed = NumberRange.new(260,260);
				Size = NumberSequence.new{NumberSequenceKeypoint.new(0,0.1,0),NumberSequenceKeypoint.new(1,0.1,0)};
				Speed = NumberRange.new(15,15);
				SpreadAngle = Vector2.new(360,360);
				Texture = "http://www.roblox.com/asset/?id=24168548";
				Parent = part
			});
			local particle4 = utility.instance_new("ParticleEmitter", {
				Acceleration = Vector3.new(0,-10,0);
				Color = ColorSequence.new{ColorSequenceKeypoint.new(0,Color3.new(0.180392,1,0)),ColorSequenceKeypoint.new(1,Color3.new(0.180392,1,0))};
				Lifetime = NumberRange.new(1,2);
				Rate = 0;
				RotSpeed = NumberRange.new(260,260);
				Size = NumberSequence.new{NumberSequenceKeypoint.new(0,0.1,0),NumberSequenceKeypoint.new(1,0.1,0)};
				Speed = NumberRange.new(15,15);
				SpreadAngle = Vector2.new(360,360);
				Texture = "http://www.roblox.com/asset/?id=241685484";
				Parent = part
			});
			local particle5 = utility.instance_new("ParticleEmitter", {
				Acceleration = Vector3.new(0,-10,0);
				Color = ColorSequence.new{ColorSequenceKeypoint.new(0,Color3.new(1,0,0)),ColorSequenceKeypoint.new(1,Color3.new(1,0,0))};
				Lifetime = NumberRange.new(1,2);
				Rate = 0;
				RotSpeed = NumberRange.new(260,260);
				Size = NumberSequence.new{NumberSequenceKeypoint.new(0,0.1,0),NumberSequenceKeypoint.new(1,0.1,0)};
				Speed = NumberRange.new(15,15);
				SpreadAngle = Vector2.new(360,360);
				Texture = "http://www.roblox.com/asset/?id=241685484";
				Parent = part
			});	
		end;

		local objects = part:GetChildren();

		for i = 1, #objects do
			local object = objects[i];

			if (object.ClassName ~= "ParticleEmitter") then continue end;

			object:Emit(1);
		end;

		task.delay(3, function()
			part:Destroy();
		end);
	end;
	
	hit_effects.bubble = function(position, color) --// credits to xander once again
		local part = utility.instance_new("Part", {
			Position = position,
			Anchored = true,
			Transparency = 1,
			CanCollide = false,
			Parent = workspace
		});
        
        local particle1 = utility.instance_new("ParticleEmitter", {
            Color = ColorSequence.new{ColorSequenceKeypoint.new(0,color),ColorSequenceKeypoint.new(1,color)};
            Lifetime = NumberRange.new(0.5,0.5);
            LightEmission = 1;
            LockedToPart = true;
            Orientation = Enum.ParticleOrientation.VelocityPerpendicular;
            Rate = 0;
            Size = NumberSequence.new{NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,10,0)};
            Speed = NumberRange.new(1.5,1.5);
            Texture = "rbxassetid://1084991215";
            Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.0996047,0,0),NumberSequenceKeypoint.new(0.602372,0,0),NumberSequenceKeypoint.new(1,1,0)};
            ZOffset = 1;
            Parent = part
        });
        local particle2 = utility.instance_new("ParticleEmitter", {
            Color = ColorSequence.new{ColorSequenceKeypoint.new(0,color),ColorSequenceKeypoint.new(1,color)};
            Lifetime = NumberRange.new(0.5,0.5);
            LightEmission = 1;
            LockedToPart = true;
            Rate = 0;
            Size = NumberSequence.new{NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,10,0)};
            Speed = NumberRange.new(0,0);
            Texture = "rbxassetid://1084991215";
            Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.0996047,0,0),NumberSequenceKeypoint.new(0.601581,0,0),NumberSequenceKeypoint.new(1,1,0)};
            ZOffset = 1;
            Parent = part
        });
        local particle3 = utility.instance_new("ParticleEmitter", {
            Color = ColorSequence.new{ColorSequenceKeypoint.new(0,Color3.new(0,0,0)),ColorSequenceKeypoint.new(1,Color3.new(0,0,0))};
            Lifetime = NumberRange.new(0.2,0.5);
            LockedToPart = true;
            Orientation = Enum.ParticleOrientation.VelocityParallel;
            Rate = 0;
            Rotation = NumberRange.new(-90,90);
            Size = NumberSequence.new{NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,8.5,1.5)};
            Speed = NumberRange.new(0.1,0.1);
            SpreadAngle = Vector2.new(180,180);
            Texture = "http://www.roblox.com/asset/?id=6820680001";
            Transparency = NumberSequence.new{NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.200791,0,0),NumberSequenceKeypoint.new(0.699605,0,0),NumberSequenceKeypoint.new(1,1,0)};
            ZOffset = 1.5;
            Parent = part
        });

		particle1:Emit(1);
		particle2:Emit(1);
        particle3:Emit(1);

		task.delay(1, function()
			part:Destroy();
		end);
	end;
end;

-- // combat
local combat = {}; do
    combat.get_closest_part = LPH_NO_VIRTUALIZE(function(Character)
        local closestPart, closestDistance = nil, math.huge

        if Character then
            for _, part in ipairs(Character:GetChildren()) do
                if part:IsA("BasePart") then
                    local position, onScreen = Workspace.CurrentCamera:WorldToScreenPoint(part.Position)

                    if onScreen then
                        local distance = (Vector2.new(position.X, position.Y) - mid).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestPart = part
                        end
                    end
                end
            end
        end

        return closestPart
    end)

    combat.get_closest_point = LPH_NO_VIRTUALIZE(function(part)
        local mouseRay = Mouse.UnitRay
        local adjustedRay = mouseRay.Origin + (mouseRay.Direction * (part.Position - mouseRay.Origin).Magnitude)

        local point = (adjustedRay.Y >= (part.Position - part.Size / 2).Y and adjustedRay.Y <= (part.Position + part.Size / 2).Y) 
            and (part.Position + Vector3.new(0, adjustedRay.Y - part.Position.Y, 0)) 
            or part.Position

        local params = RaycastParams.new()
        params.FilterType = Enum.RaycastFilterType.Whitelist
        params.FilterDescendantsInstances = {part}

        local ray = Workspace:Raycast(adjustedRay, (point - adjustedRay), params)

        return ray and ray.Position or Mouse.Hit.Position
    end)

combat.get_closest_player = LPH_NO_VIRTUALIZE(function(radius)
    local closestDistance, closestPlayer = radius

    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end

        local character = player.Character
        local rootPart = character and character:FindFirstChild('HumanoidRootPart')

        if not rootPart then continue end

        local rootPosition = utility.world_to_screen(rootPart.Position)
        if not rootPosition.on_screen then continue end

        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        local magnitude = (screenCenter - rootPosition.position).Magnitude

        if magnitude > closestDistance then continue end

        closestDistance = magnitude
        closestPlayer = player
    end

    return closestPlayer
end)

    combat.get_closest_triggerbot_player = LPH_NO_VIRTUALIZE(function()
        local minDistance = Configurations.TriggerBot.Range+15
        local mousePos = Camera.ViewportSize * 0.5
        local closestPlayer = nil

        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer then
                local character = player.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                
                if hrp then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                    
                    if onScreen then
                        local screenPosVec2 = Vector2.new(screenPos.X, screenPos.Y)
                        local distance = (screenPosVec2 - mousePos).Magnitude

                        if distance < minDistance and distance ~= nil then
                            minDistance = distance
                            closestPlayer = player
                        end
                    end
                end
            end
        end
        
        return closestPlayer
    end)

    combat.calculate_resolver_offset = LPH_NO_VIRTUALIZE(function(player)
        local prediction = Configurations.Target.Prediction
        local offset

        if Configurations.Resolver.Enabled then
            local method = Configurations.Resolver.Method
            local rootPart = player.Character.HumanoidRootPart

            if method == "Recalculate" then
                offset = custom_math.recalculate_velocity(player) * prediction
            elseif method == "Zero Prediction" then
                offset = Vector3.new(rootPart.Velocity.X, 0, rootPart.Velocity.Z) * prediction
            elseif method == "Move Direction" then
                offset = player.Character.Humanoid.MoveDirection * 19.64285714289 * prediction
            elseif method == "LookVector" then
                offset = player.Character[Configurations.Target.HitPart.Part].CFrame.LookVector * prediction
            end
        end

        return offset
    end)

    combat.aim_viewer_calculator = LPH_NO_VIRTUALIZE(function()
        if Target and Target.Character and Configurations.Resolver.AntiAimViewer then
            local endpoint
            if Configurations.Resolver.Enabled then
                endpoint = Script.Locals.AimPoint + combat.calculate_resolver_offset(Target)
            else
                endpoint = Script.Locals.AimPoint + (Target.Character[Script.Locals.HitPart].Velocity * Configurations.Target.Prediction)
            end
            remote:FireServer(mouse_argument, endpoint)
        end
    end)
end


-- // Drawings
local Line = utility.drawing_new("Line", {
    Visible = false,
    Color = MainColor,
    Thickness = 2,
    Transparency = 0.5,
})

local Dot = utility.drawing_new("Circle", {
    Visible = false,
    Filled = false,
    Color = MainColor,
})

local c_sync_dot = utility.drawing_new("Circle", {
    Visible = false,
    Filled = true
})

local c_sync_tracer = utility.drawing_new("Line", {
    Visible = false,
    Color = MainColor,
    Thickness = 2
})

-- // Instances
local target_chams = utility.instance_new("Highlight", {
    Parent = nil,
    FillColor = MainColor,
    OutlineColor = MainColor,
})

local local_chams = utility.instance_new("Highlight", {
    Parent = nil,
    FillColor = MainColor,
    OutlineColor = MainColor,
})

local function is_in_air(player)
    if not player.Character or not player.Character:FindFirstChild("Humanoid") then 
        return false 
    end

    local root_part = player.Character.HumanoidRootPart
    return root_part.Velocity.Y ~= 0
end

local last_heartbeat = tick()
local heartbeat_interval = 0  -- Throttle updates to ~33 FPS
do -- // connections
    do -- // silent aim connections
        utility.new_connection(RunService.Heartbeat, function()
            if tick() - last_heartbeat < heartbeat_interval then return end
            last_heartbeat = tick()
            
            -- Auto Prediction
            if Configurations.Target.AutoPrediction then
                Configurations.Target.Prediction = custom_math.get_auto_prediction()
            end

            -- Targeting logic
            if is_targetting and Target and utility.has_character(Target) then
                local hitPartName
                if Configurations.Target.HitPart.ClosestPart then
                    hitPartName = tostring(combat.get_closest_part(Target.Character))
                    if Configurations.Target.HitPart.Mode == "Nearest Part" then
                        Script.Locals.HitPart = hitPartName
                        Script.Locals.AimPoint = Target.Character[hitPartName].Position
                    elseif Configurations.Target.HitPart.Mode == "Nearest Point" then
                        Script.Locals.HitPart = hitPartName
                        Script.Locals.AimPoint = combat.get_closest_point(Target.Character[hitPartName])
                    end
                else
                    Script.Locals.HitPart = Configurations.Target.HitPart.Part
                    Script.Locals.AimPoint = Target.Character[Script.Locals.HitPart].Position
                end

                -- Calculate Position and Camera Lock
                local Position = Camera:WorldToViewportPoint(Target.Character[Script.Locals.HitPart].Position)

                if Configurations.Resolver.Enabled then
                    offset = combat.calculate_resolver_offset(Target)
                end
                
                if Configurations.Target.LookAt then
                     LocalPlayer.Character.Humanoid.AutoRotate = false
                     LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(LocalPlayer.Character.HumanoidRootPart.CFrame.Position, Vector3.new(Target.Character.HumanoidRootPart.CFrame.X, LocalPlayer.Character.HumanoidRootPart.CFrame.Position.Y, Target.Character.HumanoidRootPart.CFrame.Z))
                else
                     LocalPlayer.Character.Humanoid.AutoRotate = true
                end
                
                if Configurations.Target.Spectate then
                     Camera.CameraSubject = Target.Character.Humanoid;
                else
                     Camera.CameraSubject = LocalPlayer.Character.Humanoid
                end
                
                if Configurations.Target.AutoArmor then
	if game.Players.LocalPlayer.Character.BodyEffects.Armor.Value < 100 then
		local Pos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
		game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = workspace.Ignored.Shop["[High-Medium Armor] - $2440"].Head.CFrame
		fireclickdetector(workspace.Ignored.Shop["[High-Medium Armor] - $2440"].ClickDetector)
		RunService.RenderStepped:Wait()
		game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = Pos
	end
end
                
                --[[if Configurations.Target.AutoAir then
    if Target and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
        local humanoid = Target.Character:FindFirstChild("Humanoid")
        if humanoid and humanoid.Jump then
            if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool") then
                if game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool").Name ~= "Silent Aim Tool" then
                    game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool"):Activate()
                end
            end
        end
    end
end--]]

if Configurations.Target.AutoAir then
    if Target and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
        local humanoid = Target.Character:FindFirstChild("Humanoid")
        
        if humanoid then
            local state = humanoid:GetState()
            local playerCharacter = game.Players.LocalPlayer.Character
            local tool = playerCharacter and playerCharacter:FindFirstChildOfClass("Tool")
            
            if (state == Enum.HumanoidStateType.Jumping or state == Enum.HumanoidStateType.Freefall) then
                if tool and tool.Name ~= "Silent Aim Tool" then
                    tool:Activate()
                end
            end
        end
    end
end

if Configurations.Target.AutoShoot then
if Target and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
    local playerCharacter = game.Players.LocalPlayer.Character
    local tool = playerCharacter and playerCharacter:FindFirstChildOfClass("Tool")
    local humanoid = Target.Character:FindFirstChild("Humanoid")

    if humanoid then

    if tool and tool.Name ~= "Silent Aim Tool" then
        tool:Activate()
    end
end
end
end


if Configurations.Target.AirPartEnabled then
    if Target and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
        if Target.Character:FindFirstChild("Humanoid"):GetState() == Enum.HumanoidStateType.Jumping or 
           Target.Character:FindFirstChild("Humanoid"):GetState() == Enum.HumanoidStateType.Freefall then
            Script.Locals.HitPart = Configurations.Target.AirPart
        end
    end
end


if Configurations.Target.Checks.AntiGroundShots and Target and Target.Character then
    if is_in_air(Target) then
        local offset = custom_math.recalculate_velocity(Target) * Configurations.Target.Prediction
        offset = Vector3.new(
            math.clamp(offset.X, -math.huge, math.huge), 
            math.clamp(offset.Y, -1, math.huge), 
            math.clamp(offset.Z, -math.huge, math.huge)
        )
    end
  end

                if Configurations.Target.CameraLock.Enabled then
                    local ShakeOffset = Vector3.new(0,0,0)
                    if Configurations.Target.CameraLock.UseShake then
                        ShakeOffset = Vector3.new(
                            math.random(-Configurations.Target.CameraLock.Shake,Configurations.Target.CameraLock.Shake),
                            math.random(-Configurations.Target.CameraLock.Shake,Configurations.Target.CameraLock.Shake),
                            math.random(-Configurations.Target.CameraLock.Shake,Configurations.Target.CameraLock.Shake)
                        ) * 0.1
                    end

                    if Configurations.Target.CameraLock.Smoothness then
                        Camera.CFrame = Camera.CFrame:Lerp(
                            CFrame.new(Camera.CFrame.Position, Target.Character[Script.Locals.HitPart].Position + Target.Character.HumanoidRootPart.Velocity * Configurations.Target.Prediction + ShakeOffset),
                            Configurations.Target.CameraLock.SmoothnessAmount
                        )
                    else
                        Camera.CFrame = CFrame.new(
                            Camera.CFrame.Position,
                            Target.Character[Script.Locals.HitPart].Position + Target.Character.HumanoidRootPart.Velocity * Configurations.Target.Prediction + ShakeOffset
                        )
                    end
                end

                -- Visuals Update
                if Configurations.Target.Enabled then
                    local predicted_position = Position

                    -- Dot
                    if Configurations.Visuals.Dot.Enabled then
                        Dot.Visible = predicted_position and true or false
                        Dot.Filled = true
                        Dot.Position = Vector2.new(predicted_position.X, predicted_position.Y)
                        Dot.Color = Configurations.Visuals.Dot.Color
                        Dot.Size = Configurations.Visuals.Dot.Size
                    end
                    
                    -- Line
                    if Configurations.Visuals.Line.Enabled then
                        local from_position = utility.world_to_screen(LocalPlayer.Character.HumanoidRootPart.Position)
                        Line.Visible = predicted_position and true or false
                        Line.From = from_position.position
                        Line.To = Vector2.new(predicted_position.X, predicted_position.Y)
                        Line.Color = Configurations.Visuals.Line.Color
                        Line.Thickness = Configurations.Visuals.Line.Thickness
                    end
                end

                -- Knocked Check
                if Configurations.Target.Checks.Knocked and Target.Character:FindFirstChild("LowerTorso") and Configurations.Target.Checks.Enabled then
                    local KOd = Target.Character:WaitForChild("BodyEffects")["K.O"].Value
                    local Grabbed = Target.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                    if KOd or Grabbed then
                        Target = nil
                    end
                end
                
                if Configurations.Misc.TargetStrafe.Enabled and 
                   (not Configurations.Misc.TargetStrafe.BypassDC or 
                    (Configurations.Misc.TargetStrafe.BypassDC and Target.Character.HumanoidRootPart.Position.Y >= -10000)) then
                    if Configurations.Target.LookAt == true then
                       Configurations.Target.LookAt = false
                       wait()
                       Configurations.Target.LookAt = true
                    end
  
                    local strafe -- Declare the variable once, outside the conditional blocks

                    if Configurations.Misc.TargetStrafe.Type == "Orbit" then
                        local current_time = tick()
                        strafe = CFrame.new(Target.Character.HumanoidRootPart.Position) * 
                                 CFrame.Angles(0, 2 * math.pi * current_time * Configurations.Misc.TargetStrafe.Speed % (2 * math.pi), 0) * 
                                 CFrame.new(0, Configurations.Misc.TargetStrafe.Height, Configurations.Misc.TargetStrafe.Distance)
                    else
                        strafe = Target.Character.HumanoidRootPart.CFrame + 
                                 custom_math.random_vector3(Configurations.Misc.TargetStrafe.Randomization)
                    end
                    
                    -- After the if-else logic, assign the value of strafe to the LocalPlayer's CFrame
                    LocalPlayer.Character.HumanoidRootPart.CFrame = strafe
                end

                -- Crosshair Update
                if getgenv().crosshair.sticky then
                    getgenv().crosshair.mode = 'custom'
                    getgenv().crosshair.position = Vector2.new(Position.X, Position.Y)
                else
                    getgenv().crosshair.mode = crosshair_position
                end
            else
                if Dot.Visible == true then
                    Dot.Visible = false
                end
                --
                if Line.Visible == true then
                    Line.Visible = false
                end
                --
                LocalPlayer.Character.Humanoid.AutoRotate = true
                Camera.CameraSubject = LocalPlayer.Character.Humanoid
                getgenv().crosshair.mode = crosshair_position
            end

            -- Target Highlight
            if Configurations.Target.Enabled and Configurations.Visuals.HighLight.Enabled and utility.has_character(Target) then
                target_chams.Parent = Target.Character
                target_chams.FillColor = Configurations.Visuals.HighLight.Fill
                target_chams.OutlineColor = Configurations.Visuals.HighLight.OutLine
            else
                target_chams.Parent = nil
            end
        end)
    end

    do -- // misc connections
        utility.new_connection(RunService.Heartbeat, function()
        if ((Configurations.Misc.CSync.Enabled) or (Configurations.Misc.CSync.VoidSpam) or (Configurations.Misc.CSync.DestroyCheaters) and LocalPlayer.Character) then
         old_hrp = LocalPlayer.Character.HumanoidRootPart.CFrame;
         local attach = (Configurations.Misc.CSync.Attach and is_targetting and Target and Target.Character and Target.Character.HumanoidRootPart) or LocalPlayer.Character.HumanoidRootPart
         local cframe_position = {
         	["Custom"] = attach.CFrame * CFrame.new(Configurations.Misc.CSync.Custom.X, Configurations.Misc.CSync.Custom.Y, Configurations.Misc.CSync.Custom.Z),
         	["Destroy Cheaters"] = attach.CFrame * CFrame.new(9e9, 0/0, math.huge),
         	["Random"] = attach.CFrame + custom_math.random_vector3(Configurations.Misc.CSync.Randomize.Value),
             ["Void Spam"] = should_haalfi_destroy and attach.CFrame * CFrame.new(0, 0/1, math.huge) or attach.CFrame
         }
         --
         local csync_type = Configurations.Misc.CSync.VoidSpam and cframe_position["Void Spam"] or Configurations.Misc.CSync.DestroyCheaters and cframe_position["Destroy Cheaters"] or cframe_position[Configurations.Misc.CSync.Type]
         --
         LocalPlayer.Character.HumanoidRootPart.CFrame = csync_type
         --
         if (Configurations.Misc.CSync.Visualize.Enabled and Configurations.Misc.CSync.Visualize.Type == "Line" and typeof(csync_type) == "CFrame") then
						local hrp_pos = utility.world_to_screen(attach.Position);
						local desynced_pos = utility.world_to_screen(csync_type.Position);

						c_sync_tracer.Visible = true;
						c_sync_tracer.From = Vector2.new(hrp_pos.position.X, hrp_pos.position.Y);
						c_sync_tracer.To = Vector2.new(desynced_pos.position.X, desynced_pos.position.Y);
						c_sync_tracer.Color = Configurations.Misc.CSync.Visualize.Color;
					else
						c_sync_tracer.Visible = false;
					end;

					if (Configurations.Misc.CSync.Visualize.Enabled and Configurations.Misc.CSync.Visualize.Type == "Dot" and typeof(csync_type) == "CFrame") then
						local desynced_pos = utility.world_to_screen(csync_type.Position);

						c_sync_dot.Visible = true;
						c_sync_dot.Color = Configurations.Misc.CSync.Visualize.Color;
						c_sync_dot.Position = desynced_pos.position;
						c_sync_dot.Radius = 10;
					else
						c_sync_dot.Visible = false;
					end;
					
         RunService.RenderStepped:Wait()
         --
         LocalPlayer.Character.HumanoidRootPart.CFrame = old_hrp
         else
         c_sync_tracer.Visible = false;
					c_sync_dot.Visible = false;
         end
         end)
         
         task.spawn(function()
			while task.wait(0.1) do
				should_haalfi_destroy = not should_haalfi_destroy;
			end;
		end);
         
        local triggerbot_last_tick = 0
        utility.new_connection(RunService.Heartbeat, function()
            local now = tick()
            if now - triggerbot_last_tick < 0 then return end -- Throttle to ~20FPS
            triggerbot_last_tick = now

            -- Triggerbot logic
            local closestPlayer = combat.get_closest_triggerbot_player()
            if closestPlayer and Configurations.TriggerBot.Enabled then
                local hrp = closestPlayer.Character and closestPlayer.Character:FindFirstChild("HumanoidRootPart")

                if hrp and Players.LocalPlayer.Character:FindFirstChildOfClass("Tool") then
                    local tool = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
                    local toolName = tool.Name
                    local validTool = toolName ~= "[Knife]" and toolName ~= "Wallet" and toolName ~= "Silent Aim Tool"

                    if validTool then
                        local aimPos = hrp.Position + hrp.Velocity * Configurations.TriggerBot.Prediction
                        local screenPos, onScreen = Camera:WorldToViewportPoint(aimPos)

                        if onScreen then
                            TriggerBotFOV.Position = Vector2.new(screenPos.X, screenPos.Y)
                            TriggerBotFOV.Visible = Configurations.TriggerBot.Visualize

                            local mousePos = Camera.ViewportSize * 0.5
                            local distance = (mousePos - TriggerBotFOV.Position).magnitude

                            if Configurations.TriggerBot.UseDelay then
                                if distance <= TriggerBotFOV.Radius then
                                    task.delay(Configurations.TriggerBot.Delay, function()
                                        tool:Activate()
                                        TriggerBotFOV.Color = Color3.fromRGB(255, 0, 0) -- Red
                                    end)
                                else
                                    TriggerBotFOV.Color = MainColor -- OG
                                end
                            else
                                tool:Activate()
                                TriggerBotFOV.Color = Color3.fromRGB(255, 0, 0) -- Red
                            end
                        else
                            TriggerBotFOV.Visible = false
                        end
                    else
                        TriggerBotFOV.Visible = false
                    end
                else
                    TriggerBotFOV.Visible = false
                end
            else
                TriggerBotFOV.Visible = false
            end
        end)

        -- // VISUALS BackTrack
        local backtrack_last_tick = 0
        utility.new_connection(RunService.Heartbeat, function()
            if Configurations.Visuals.BackTrack.Enabled and tick() - backtrack_last_tick >= Configurations.Visuals.BackTrack.Duration then
                backtrack_last_tick = tick()

                local players_apply = {
                    ["Local Player"] = LocalPlayer,
                    ["Target"] = Target
                }

                -- Create a table for 'ApplyTo'
                local to_apply_table = type(Configurations.Visuals.BackTrack.ApplyTo) == "string" 
                    and {Configurations.Visuals.BackTrack.ApplyTo} 
                    or Configurations.Visuals.BackTrack.ApplyTo

                -- Iterate through players to apply the backtrack effect
                for i = 1, #to_apply_table do
                    local to_apply = to_apply_table[i]
                    local player = players_apply[to_apply]

                    if player and utility.has_character(player) then
                          local model = utility.clone_character(
                            player,
                            Configurations.Visuals.BackTrack.Transparency,
                            Configurations.Visuals.BackTrack.Color,
                            "Neon",
                            true
                        )

                        -- Schedule destruction of the clone after the backtrack duration
                        task.delay(Configurations.Visuals.BackTrack.Duration, function()
                            if model then model:Destroy() end
                        end)
                    end
                end
            end

            -- World Settings Update
            Lighting.FogColor = Configurations.Visuals.World.Enabled and Configurations.Visuals.World.Fog.Enabled and Configurations.Visuals.World.Fog.Color or Script.World.FogColor
            Lighting.FogStart = Configurations.Visuals.World.Enabled and Configurations.Visuals.World.Fog.Enabled and Configurations.Visuals.World.Fog.Start or Script.World.FogStart
            Lighting.FogEnd = Configurations.Visuals.World.Enabled and Configurations.Visuals.World.Fog.Enabled and Configurations.Visuals.World.Fog.End or Script.World.FogEnd
            Lighting.Ambient = Configurations.Visuals.World.Enabled and Configurations.Visuals.World.Ambient.Enabled and Configurations.Visuals.World.Ambient.Color or Script.World.Ambient
            Lighting.Brightness = Configurations.Visuals.World.Enabled and Configurations.Visuals.World.Brightness.Enabled and Configurations.Visuals.World.Brightness.Value or Script.World.Brightness
            Lighting.ClockTime = Configurations.Visuals.World.Enabled and Configurations.Visuals.World.ClockTime.Enabled and Configurations.Visuals.World.ClockTime.Value or Script.World.ClockTime
            Lighting.ExposureCompensation = Configurations.Visuals.World.Enabled and Configurations.Visuals.World.WorldExposure.Enabled and Configurations.Visuals.World.WorldExposure.Value or Script.World.ExposureCompensation
        end)
    end
end


Tool.Activated:Connect(function()
    if Configurations.Target.Enabled then
        is_targetting = not is_targetting
        local NewTarget = combat.get_closest_player(150)
        Target = is_targetting and NewTarget or nil
        if Configurations.Target.Notify then
            Notifications:New('Target: ' .. tostring(Target), 5, MainColor)
       end
    end
end)

do -- // hit detection
    local function FindTargetOnPart(Part)
        local Target,HitPart = nil,nil
        local Distance = 2

        for _,Player in pairs(game.Players:GetPlayers()) do
            if Player == LocalPlayer then continue end

            local Char = Player.Character
            local Root = Char and Char:FindFirstChild("HumanoidRootPart")

            for _,Obj in pairs(Char:GetChildren()) do
                if not Obj:IsA("BasePart") then continue end
                local Mag = (Obj.Position - Part.Position).Magnitude
                if Mag < Distance then
                    Distance = Mag
                    Target = Player
                    HitPart = Obj
                end
            end
        end

        return Target,HitPart
    end
local BladLock = Instance.new("ScreenGui")
BladLock.Name = "BladLock"
BladLock.Parent = game.CoreGui
BladLock.ZIndexBehavior = Enum.ZIndexBehavior.Global

local Frame = Instance.new("Frame")
Frame.Parent = BladLock
Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.133798108, 0, 0.20107238, 0)
Frame.Size = UDim2.new(0, 80, 0, 70)
Frame.Active = true
Frame.Draggable = true

local Logo = Instance.new("ImageLabel")
Logo.Name = "Logo"
Logo.Parent = Frame
Logo.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Logo.BackgroundTransparency = 5.000
Logo.BorderColor3 = Color3.fromRGB(0, 0, 0)
Logo.BorderSizePixel = 0
Logo.Position = UDim2.new(0.326732665, 0, 0, 0)
Logo.Size = UDim2.new(0, 43, 0, 43)
Logo.Image = "rbxassetid://YOUR_IMAGE_ID"
Logo.ImageTransparency = 0.200


local TextButton = Instance.new("TextButton")
TextButton.Parent = Frame
TextButton.BackgroundColor3 = Color3.fromRGB(71, 71, 71)
TextButton.BackgroundTransparency = 5.000
TextButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextButton.BorderSizePixel = 0
TextButton.Position = UDim2.new(0.0792079195, 0, 0.18571429, 0)
TextButton.Size = UDim2.new(0, 80, 0, 44)
TextButton.Font = Enum.Font.SourceSansSemibold
TextButton.Text = "Lock Button"
TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
TextButton.TextScaled = true
TextButton.TextSize = 14.000
TextButton.TextWrapped = true


local UICorner = Instance.new("UICorner")
UICorner.Parent = Frame

local state = true
TextButton.MouseButton1Click:Connect(function()
    if Configurations.Target.Enabled then
        is_targetting = not is_targetting
        local NewTarget = combat.get_closest_player(150)
        Target = is_targetting and NewTarget or nil
        if Configurations.Target.Notify then
            Notifications:New('Target: ' .. tostring(Target), 5, MainColor)
        end
    end
end)

local UICorner2 = Instance.new("UICorner")
UICorner2.Parent = TextButton
    local function SirenAdded(Obj)
        local Character = LocalPlayer.Character
        local RootPart = Character and Character:FindFirstChild("HumanoidRootPart")

        local function VerifyBullet(obj)
            return (obj.Name == bullet_name or obj:FindFirstChild("Attachment") or obj:FindFirstChild(bullet_beam_name)) and obj
        end

        local PlayerChecks = {PlayerGun = false}
        local BulletRay = VerifyBullet(Obj)
    
        if BulletRay and RootPart then
            local Mag = (RootPart.Position - BulletRay.Position).Magnitude
            if Mag <= 13 then PlayerChecks.PlayerGun = true end

            if PlayerChecks.PlayerGun then
                local GunBeam = BulletRay:WaitForChild(bullet_beam_name)
                
                local Attachment0 = GunBeam.Attachment0 -- closest to player
                local Attachment1 = GunBeam.Attachment1 -- mouse position
    
                if Configurations.Visuals.Bullet_Trails.Enabled then
                    GunBeam:Destroy()
                    utility.create_beam(BulletRay.Position, Attachment1.WorldCFrame.Position, Configurations.Visuals.Bullet_Trails.Color, Configurations.Visuals.Bullet_Trails.Color, Configurations.Visuals.Bullet_Trails.Duration, Configurations.Visuals.Bullet_Trails.Fade, Configurations.Visuals.Bullet_Trails.FadeDuration)
                end
                
                if Configurations.Visuals.Bullet_Impacts.Enabled then
                    utility.create_impact(Configurations.Visuals.Bullet_Impacts.Color, Configurations.Visuals.Bullet_Impacts.Width, Configurations.Visuals.Bullet_Impacts.Fade, Configurations.Visuals.Bullet_Impacts.FadeDuration, Configurations.Visuals.Bullet_Impacts.Duration, Attachment1.WorldPosition)
                end                
                
                if Configurations.Visuals.Hit_Detection.Enabled then
                    local Part = Instance.new('Part', workspace)
                    Part.Anchored = true
                    Part.Size = Vector3.new(0.25, 0.25, 0.25)
                    Part.Position = Attachment1.WorldCFrame.Position
                    Part.Material = Enum.Material.Neon
                    Part.Color = MainColor
                    Part.CanCollide = false
                    Part.Transparency = 1
    
                    Debris:AddItem(Part,2)
    
                    local Target,HitPart = FindTargetOnPart(Part)
                    if Target then
                        if Configurations.Visuals.Hit_Detection.Notify then
                            Menu.Notify('frost<font color="#'..tostring(MainColor:ToHex())..'">.lol</font> | '..tostring(HitPart)..' | Target : '..Target.DisplayName,1.5)                            
                        end

                        if Configurations.Visuals.Hit_Detection.Clone then
                            local new_character = utility.clone_character(Target,0.5,MainColor,"Neon")
                            task.delay(4,function() new_character:Destroy() end)
                        end

                        if Configurations.Visuals.Hit_Detection.HitEffect then
                            if Configurations.Visuals.Hit_Detection.HitEffectType == "Nova" then
                                hit_effects.bubble(Target.Character.HumanoidRootPart.CFrame.Position,MainColor)
                            elseif Configurations.Visuals.Hit_Detection.HitEffectType == "Confetti" then
                                hit_effects.confetti(Target.Character.HumanoidRootPart.CFrame.Position)
                             elseif Configurations.Visuals.Hit_Detection.HitEffectType == "Slash" then
                                 hit_effects.slash(Target.Character.HumanoidRootPart.CFrame.Position)
                             elseif Configurations.Visuals.Hit_Detection.HitEffectType == "Cosmic Explosion" then
                                 hit_effects.cosmic_explosion(Target.Character.HumanoidRootPart.CFrame.Position)
                             elseif Configurations.Visuals.Hit_Detection.HitEffectType == "Crescent Slash" then
                                 hit_effects.crescent_slash(Target.Character.HumanoidRootPart.CFrame.Position)
                             elseif Configurations.Visuals.Hit_Detection.HitEffectType == "Atomic Slash" then
                                 hit_effects.atomic_slash(Target.Character.HumanoidRootPart.CFrame.Position)
                              elseif Configurations.Visuals.Hit_Detection.HitEffectType == "Cum" then
                                 hit_effects.cum(Target.Character.HumanoidRootPart.CFrame.Position)
                            end
                        end

                        if Configurations.Visuals.Hit_Detection.Sound then
                            local Sound = utility.instance_new("Sound", {
                                SoundId = Script.HitSounds[Configurations.Visuals.Hit_Detection.HitSound],
                                Volume = 1,
                                Parent = Obj
                            })
                            Sound:Play()
                        end
                    end
                end
            end
        end
    end

    if bullet_path then bullet_path.ChildAdded:Connect(SirenAdded) end
end

do -- // Hooking
    __namecall = hookmetamethod(game, "__namecall", newcclosure(function(Self, ...)
        local args, method = {...}, tostring(getnamecallmethod())
        
        if not checkcaller() and method == "FireServer" then
            for i, arg in pairs(args) do
                if typeof(arg) == "Vector3" then
                    if Target and Configurations.Target.Enabled and not Configurations.Resolver.AntiAimViewer then
                        args[i] = Script.Locals.AimPoint + (Configurations.Resolver.Enabled and offset or Target.Character[Script.Locals.HitPart].Velocity * Configurations.Target.Prediction)
                    end
                    return __namecall(Self, unpack(args))
                elseif type(arg) == "table" then
                    for index, element in ipairs(arg) do
                        if typeof(element) == "Vector3" and Target and Configurations.Target.Enabled and not Configurations.Resolver.AntiAimViewer then
                            arg[index] = Script.Locals.AimPoint + (Configurations.Resolver.Enabled and offset or Target.Character[Script.Locals.HitPart].Velocity * Configurations.Target.Prediction)
                        end
                    end
                end
            end
            return __namecall(Self, unpack(args))
        end
        
        return __namecall(Self, ...)
    end))

    local old
    old = hookmetamethod(game, "__index", LPH_NO_VIRTUALIZE(function(self, key)
        if not checkcaller() then
            if key == "CFrame" and LocalPlayer.Character and self == LocalPlayer.Character.HumanoidRootPart and ((Configurations.Misc.CSync.Enabled) or (Configurations.Misc.CSync.DestroyCheaters) or (Configurations.Misc.CSync.VoidSpam)) and old_hrp ~= nil and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character:FindFirstChild("Humanoid") and LocalPlayer.Character:FindFirstChild("Humanoid").Health > 0 then
                return old_hrp
            end
        end 
        return old(self, key)
    end))
end

function Gun(Name)
    for Check = 1, 100000 do
        if game.Workspace.Ignored.Shop:FindFirstChild("[" .. Name .. "] - $" .. Check) then
            return tostring("[" .. Name .. "] - $" .. Check)
        end
    end
end

function Ammo(Name)
    for Check1 = 1, 250 do
        for Check2 = 1, 500 do
            if game.Workspace.Ignored.Shop:FindFirstChild(Check1 .. " [" .. Name .. " Ammo] - $" .. Check2) then
                return tostring(Check1 .. " [" .. Name .. " Ammo] - $" .. Check2)
            end
        end
    end
end

function Buy(Target, Delay, LagBack, Times)
    if Times == nil then
        Times = 3
    end
    local item = game.Workspace.Ignored.Shop:FindFirstChild(Target)
    if item then
        savepos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
        for i = 1, Times do
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = item.Head.CFrame * CFrame.new(0, 3, 0)
            task.wait(0.5)
            for i = 1, 10 do
                fireclickdetector(item.ClickDetector)
            end
            task.wait(0.5)
        end
        if LagBack then
            task.wait(1)
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = savepos
        end
        if Delay ~= nil then
            task.wait(Delay)
        end
    end
end

function BuyGunAndAmmo(GUN, times)
    if
        game.Players.LocalPlayer.Backpack:FindFirstChild("[" .. GUN .. "]") or
            game.Players.LocalPlayer.Character:FindFirstChild("[" .. GUN .. "]")
     then
        Buy(Ammo(GUN), 0.3, true, times)
    else
        Buy(Gun(GUN), 0.5, true)
    end
end

local player = game.Players.LocalPlayer
local RunService = game:GetService("RunService")

local function locateItem(itemName)
    for price = 1, 100000 do
        local fullName = "[" .. itemName .. "] - $" .. price
        local item = game.Workspace.Ignored.Shop:FindFirstChild(fullName)
        if item then
            return item, price
        end
    end
  end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

local ScreenGui = Instance.new("ScreenGui")
local ImageButton = Instance.new("ImageButton")


ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.ResetOnSpawn = false

ImageButton.Parent = ScreenGui
ImageButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ImageButton.BackgroundTransparency = 1.000
ImageButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
ImageButton.BorderSizePixel = 0
ImageButton.Position = UDim2.new(0.744, 0,0.145, 0)
ImageButton.Size = UDim2.new(0.0914429501, 0, 0.15372169, 0)
ImageButton.Image = "rbxassetid://86865501962131"

-- UI Visibility Toggle
local isVisible = true
local function toggleUI()
    isVisible = not isVisible
    Menu:SetVisible(isVisible)
end
ImageButton.MouseButton1Down:Connect(toggleUI)

-- Text Size Constraint
local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
UITextSizeConstraint.Parent = TextButton
UITextSizeConstraint.MaxTextSize = 30

-- Character Added Event
local player = game.Players.LocalPlayer
local function onCharacterAdded(character)
    ScreenGui.Parent = player.PlayerGui
end
player.CharacterAdded:Connect(onCharacterAdded)
player.CharacterRemoving:Connect(function() ScreenGui.Parent = nil end)

-- Menu Name Update
local function MenuNameUpdate()
    while task.wait() do
        local Name = 'frost'
        local PlaceHolder = ''
        for i = 1, #Name do
            PlaceHolder = PlaceHolder .. string.sub(Name, i, i)
            Menu:SetTitle(PlaceHolder .. '<font color="#' .. tostring(Menu.Accent:ToHex()) .. '">.lol</font> | GUI')
            task.wait(0.25)
        end
    end
end
task.spawn(MenuNameUpdate)

-- Setup Menu
Menu:SetSize(500,400)
Menu.Accent = MainColor
Menu:SetVisible(true)
Menu:Init()

-- Create Tabs
local CombatTab = Menu.Tab("Main")
local MiscTab = Menu.Tab("Misc")
local VisualsTab = Menu.Tab("Visuals")
local ConfigsTab = Menu.Tab("Configuration")

Menu.Container("Main", "Target Aim", "Left")
Menu.CheckBox("Main", "Target Aim", "Enabled", Configurations.Target.Enabled, function(a)
    Configurations.Target.Enabled = a
end)

Menu.TextBox("Main", "Target Aim", "Prediction", '0.135', function(a)
    Configurations.Target.Prediction = a
end)

Menu.CheckBox("Main", "Target Aim", "Auto Prediction", Configurations.Target.AutoPrediction, function(a)
    Configurations.Target.AutoPrediction = a
end)

Menu.CheckBox("Main", "Target Aim", "Look At", Configurations.Target.LookAt, function(a)
    Configurations.Target.LookAt = a
end)

Menu.CheckBox("Main", "Target Aim", "Spectate", Configurations.Target.Spectate, function(a)
    Configurations.Target.Spectate = a
end)

Menu.CheckBox("Main", "Target Aim", "AutoAir", Configurations.Target.AutoAir, function(a)
    Configurations.Target.AutoAir = a
    end)
    
    Menu.CheckBox("Main", "Target Aim", "AutoShoot", Configurations.Target.AutoShoot, function(a)
        Configurations.Target.AutoShoot = a
        end)

Menu.CheckBox("Main", "Target Aim", "Notify", Configurations.Target.Notify, function(a)
    Configurations.Target.Notify = a
end)

Menu.CheckBox("Main", "Target Aim", "Camera Lock", Configurations.Target.CameraLock.Enabled, function(a)
    Configurations.Target.CameraLock.Enabled = a
end)


Menu.Container("Main", "Hit Part", "Left")
Menu.CheckBox("Main", "Hit Part", "Nearest Part", false, function(a)
    Configurations.Target.HitPart.ClosestPart = a
end)


Menu.ComboBox("Main", "Hit Part", "Nearest Part Mode", "Nearest Part", {"Nearest Point", "Nearest Part"}, function(a)
    Configurations.Target.HitPart.Mode = a
end)

Menu.ComboBox("Main", "Hit Part", "Hit Part", "HumanoidRootPart", {"Head", "LeftHand", "RightHand", "LeftLowerArm", "RightLowerArm", "LeftUpperArm", "RightUpperArm", "LeftFoot", "LeftLowerLeg", "UpperTorso", "HumanoidRootPart", "LeftUpperLeg", "RightLowerLeg", "RightFoot", "LowerTorso"}, function(a)
    Configurations.Target.HitPart.Part = a
end)

Menu.CheckBox("Main", "Hit Part", "AirPart", Configurations.Target.AirPartEnabled, function(a)
            Configurations.Target.AirPartEnabled = a
            end)

Menu.ComboBox("Main", "Hit Part", "Air Part", "Head", {"Head", "LeftHand", "RightHand", "LeftLowerArm", "RightLowerArm", "LeftUpperArm", "RightUpperArm", "LeftFoot", "LeftLowerLeg", "UpperTorso", "HumanoidRootPart", "LeftUpperLeg", "RightLowerLeg", "RightFoot", "LowerTorso"}, function(a)
    Configurations.Target.AirPart = a
    end)

Menu.Container("Main", "Trigger Bot", "Right")
Menu.CheckBox("Main", "Trigger Bot", "Enabled", Configurations.TriggerBot.Enabled, function(a)
    Configurations.TriggerBot.Enabled = a
end)

Menu.TextBox("Main", "Trigger Bot", "Prediction", '0.135', function(a)
    Configurations.TriggerBot.Prediction = a
end)

Menu.CheckBox("Main", "Trigger Bot", "Visualize", Configurations.TriggerBot.Visualize, function(a)
    Configurations.TriggerBot.Visualize = a
end)

Menu.CheckBox("Main", "Trigger Bot", "Use Delay", Configurations.TriggerBot.UseDelay, function(a)
    Configurations.TriggerBot.UseDelay = a
end)

Menu.TextBox("Main", "Trigger Bot", "Delay", '0.02', function(a)
    Configurations.TriggerBot.Delay = a
end)

Menu.Slider('Main', 'Trigger Bot', 'Range', 1, 100, 2, '', 1, function(Value)
    Configurations.TriggerBot.Range = Value
end)

Menu.Container("Main", "Camera Lock Settings", "Right")
Menu.CheckBox("Main", "Camera Lock Settings", "Use Shake", Configurations.Target.CameraLock.UseShake, function(a)
    Configurations.Target.CameraLock.UseShake = a
end)

Menu.Slider("Main", "Camera Lock Settings", "Shake Value", 1, 100, 2, "", 1, function(Value)
    Configurations.Target.CameraLock.Shake = Value
end)

Menu.CheckBox("Main", "Camera Lock Settings", "Use Smoothness", Configurations.Target.CameraLock.Smoothness, function(a)
    Configurations.Target.CameraLock.Smoothness = a
end)

Menu.TextBox("Main", "Camera Lock Settings", "Smoothness Amount", "0.1", function(a)
    Configurations.Target.CameraLock.SmoothnessAmount = a
end)

Menu.ComboBox("Main", "Camera Lock Settings", "Easing Style", "Elastic", {"Elastic","Sine","Quad","Back","Linear","Exponential","Circular","Cubic","Quad","Quirt"}, function(a)
    Configurations.Target.CameraLock.Style = a
end)

Menu.ComboBox("Main", "Camera Lock Settings", "Easing Direction", "InOut", {"In","Out","InOut"}, function(a)
    Configurations.Target.CameraLock.Direction = a
end)

Menu.Container("Main", "Resolver", "Left")
Menu.CheckBox("Main", "Resolver", "Enabled", Configurations.Resolver.Enabled, function(a)
    Configurations.Resolver.Enabled = a
end)

Menu.CheckBox("Main", "Resolver", "Anti Aim Viewer", Configurations.Resolver.AntiAimViewer, function(a)
    Configurations.Resolver.AntiAimViewer = a
end)

Menu.ComboBox("Main", "Resolver", "Method", "Recalculate", {"Recalculate", "LookVector", "Move Direction", "Zero Prediction"}, function(a)
    Configurations.Resolver.Method = a
end)

Menu.Container("Main", "Checks", "Left")
Menu.CheckBox("Main", "Checks", "Enabled", Configurations.Target.Checks.Enabled, function(a)
    Configurations.Target.Checks.Enabled = a
end)

Menu.CheckBox("Main", "Checks", "Knocked", Configurations.Target.Checks.Knocked, function(a)
    Configurations.Target.Checks.Knocked = a
end)

Menu.CheckBox("Main", "Checks", "Grabbed", Configurations.Target.Checks.Grabbed, function(a)
    Configurations.Target.Checks.Grabbed = a
end)

Menu.CheckBox("Main", "Checks", "AntiGroundShots", Configurations.Target.Checks.AntiGroundShots, function(a)
    Configurations.Target.Checks.AntiGroundShots = a
end)

local TSSection = Menu.Container("Main", "Target Strafe", "Right") do
    Menu.CheckBox("Main", "Target Strafe", "Enabled", false, function(a)
        Configurations.Misc.TargetStrafe.Enabled = a
    end)
    
    Menu.CheckBox("Main", "Target Strafe", "Bypass Destroy Cheaters", false, function(a)
        Configurations.Misc.TargetStrafe.BypassDC = a
    end)
    
    Menu.ComboBox("Main", "Target Strafe", "Method", "Orbit", {"Orbit", "Randomize"}, function(a)
        Configurations.Misc.TargetStrafe.Type = a
    end)
    
    Menu.Slider("Main", "Target Strafe", "Distance", 0, 50, 9, '', 1, function(a)
        Configurations.Misc.TargetStrafe.Distance = a
    end)
    
    Menu.Slider("Main", "Target Strafe", "Speed", 0, 15, 1, '', 1, function(a)
        Configurations.Misc.TargetStrafe.Speed = a
    end)
    
    Menu.Slider("Main", "Target Strafe", "Height", 0, 15, 0, '', 1, function(a)
        Configurations.Misc.TargetStrafe.Height = a
    end)
    
    Menu.Slider("Main", "Target Strafe", "Randomization Value", 1, 50, 2, '', 1, function(Value)
        Configurations.Misc.TargetStrafe.Randomization = Value
    end)
end

local SelectedGun = "LMG"
local SelectedFood = "Taco"

Menu.Container("Misc", "Buy", "Right")

Menu.Slider('Misc', 'Buy', 'Multiplier', 1, 10, 1, '', 1, function(Value)
    autobuymultiplier = Value
end)

Menu.ComboBox('Misc', 'Buy', 'Gun', 'LMG', Guns, function(self)
    SelectedGun = self
    Configurations.Misc.AutoBuy.SelectedGun = SelectedGun
end)

Menu.Button('Misc', 'Buy', 'Buy Gun', function()
    BuyGunAndAmmo(SelectedGun, autobuymultiplier)
end)

Menu.ComboBox('Misc', 'Buy', 'Food', 'Taco', Food, function(self)
    SelectedFood = self
    Configurations.Misc.AutoBuy.SelectedFood = SelectedFood
end)

Menu.Button('Misc', 'Buy', 'Buy Food', function()
    Buy(Gun(SelectedFood), 0.3, true, 1)
end)
local Player = game.Players.LocalPlayer
local Dances = {
    Floss = 10714340543
}

local currentAnimation

local function AnimPlay(ID, SPEED)
    if currentAnimation then
        currentAnimation:Stop()
    end

    local animation = Instance.new('Animation')
    animation.AnimationId = 'rbxassetid://' .. ID

    currentAnimation = Player.Character.Humanoid:LoadAnimation(animation)
    currentAnimation:Play()
    currentAnimation:AdjustSpeed(tonumber(SPEED) or 1)

    animation:Destroy()
end

Menu.Container("Misc", "Animation", "Right")

Menu.ComboBox('Misc', 'Animation', 'Dance', 'Floss', {"Floss"}, function(self)
    Configurations.Misc.Animation.SelectedDance = self
end)

Menu.Slider('Misc', 'Animation', 'Speed', 0, 1, 0, '', 1, function(Value)
    Configurations.Misc.Animation.Speed = Value
end)

Menu.CheckBox("Misc", "Animation", "Enabled", Configurations.Misc.Animation.Enabled, function(state)
    Configurations.Misc.Animation.Enabled = state
    if Configurations.Misc.Animation.Enabled then
        local selectedDance = Dances[Configurations.Misc.Animation.SelectedDance or "Floss"]
        if selectedDance then
            AnimPlay(selectedDance, Configurations.Misc.Animation.Speed or 1)
        end
    else
        if currentAnimation then
            currentAnimation:Stop()
            currentAnimation = nil
        end
    end
end)

local Section7 = Menu.Container("Misc", "Anti Aim", "Left") do
    Menu.CheckBox("Misc", "Anti Aim", "Void Spam", false, function(a)
        Configurations.Misc.CSync.VoidSpam = a
    end)
    
    Menu.CheckBox("Misc", "Anti Aim", "Destroy Cheaters", false, function(a)
        Configurations.Misc.CSync.DestroyCheaters = a
    end)
    
    Menu.CheckBox("Misc", "Anti Aim", "Anti-Void", false, function(a)
    Workspace.FallenPartsDestroyHeight = a and -50000 or -500
end)

Menu.CheckBox("Misc", "Anti Aim", "Auto-Armor", false, function(a)
    Configurations.Target.AutoArmor = a
    end)

    
    Menu.CheckBox("Misc", "Anti Aim", "Network Desync", false, function(a)
end)
    
    Menu.CheckBox("Misc", "Anti Aim", "C-Sync", false, function(a)
        Configurations.Misc.CSync.Enabled = a
    end)
    
    Menu.ComboBox("Misc", "Anti Aim", "C-Sync Type", "Random", {"Random", "Custom"}, function(a)
        Configurations.Misc.CSync.Type = a
    end)
    
    
    Menu.Slider("Misc", "Anti Aim", "CFrame Desync Randomization", 1, 50, 1, "", 1, function(a)
        Configurations.Misc.CSync.Randomize.Value = a
    end)
    
    Menu.Slider("Misc", "Anti Aim", "CFrame Desync Customization", 1, 50, 1, "", 1, function(a)
        Configurations.Misc.CSync.Custom.X = a
        Configurations.Misc.CSync.Custom.Y = a
        Configurations.Misc.CSync.Custom.Z = a
    end)
end

Menu.Container("Misc", "CFrame Movement", "Left")
Menu.Button('Misc', 'CFrame Movement', 'Load Button', function()
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ResetOnSpawn = false
local ToggleButton = Instance.new("TextButton")
ToggleButton.Text = "Toggle Speed"
ToggleButton.Parent = ScreenGui
ToggleButton.BackgroundTransparency = 0.5
ToggleButton.BorderSizePixel = 0
ToggleButton.Position = UDim2.new(0.853, -120,-0.087, 75) -- Adjusted the position to top right corner
ToggleButton.Size = UDim2.new(0, 100, 0, 18)
ToggleButton.BackgroundColor3 = MainColor
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
local UICorner = Instance.new("UICorner")
UICorner.Parent = ToggleButton
local function onButtonClicked()
    Configurations.Misc.CSync.CFrameSpeed.Enabled = not Configurations.Misc.CSync.CFrameSpeed.Enabled
end
ToggleButton.MouseButton1Click:Connect(onButtonClicked)

game:GetService("RunService").Stepped:Connect(function()
    if Configurations.Misc.CSync.CFrameSpeed.Enabled then
        LocalPlayer.Character.HumanoidRootPart.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame + LocalPlayer.Character.Humanoid.MoveDirection * Configurations.Misc.CSync.CFrameSpeed.Speed
    end
end)
end)

Menu.Slider('Misc', 'CFrame Movement', 'Speed Amount', 1, 10, 1, '', 1, function(Value)
    Configurations.Misc.CSync.CFrameSpeed.Speed = Value
    end)

local Section7 = Menu.Container("Visuals", "Crosshair", "Right") do
    Menu.CheckBox("Visuals", "Crosshair", "Enabled", true, function(a)
        getgenv().crosshair.enabled = a
    end)
    Menu.ColorPicker("Visuals", "Crosshair", "Color", MainColor, 0, function(a)
        getgenv().crosshair.color = a
    end)
    Menu.CheckBox("Visuals", "Crosshair", "Stick To Target", false, function(a)
        getgenv().crosshair.sticky = a
    end)
    Menu.ComboBox("Visuals", "Crosshair", "Position", "Middle", {"Middle", "Mouse"}, function(a)
        crosshair_position = a
    end)

    Menu.Slider("Visuals", "Crosshair", "Thickness", 1, 5, 2.5, "", 1, function(a)
        getgenv().crosshair.width = a
    end)
    Menu.Slider("Visuals", "Crosshair", "Size", 1, 50, 10, "", 0, function(a)
        getgenv().crosshair.length = a
    end)
    Menu.Slider("Visuals", "Crosshair", "Gap", 0, 20, 11, "", 1, function(a)
        getgenv().crosshair.radius = a
    end)

    Menu.CheckBox("Visuals", "Crosshair", "Spin", getgenv().crosshair.spin, function(a)
        getgenv().crosshair.spin = a
    end)
    Menu.Slider("Visuals", "Crosshair", "Spin Speed", 1, 340, 150, "", 0, function(a)
        getgenv().crosshair.spin_speed = a
    end)

    Menu.CheckBox("Visuals", "Crosshair", "Resize", getgenv().crosshair.resize, function(a)
        getgenv().crosshair.resize = a
    end)
    Menu.Slider("Visuals", "Crosshair", "Resize Speed", 1, 22, 5, "", 0, function(a)
        getgenv().crosshair.resize_speed = a
    end)
end

local TLHightlightSection = Menu.Container("Visuals", "HighLight", "Right") do
    Menu.CheckBox("Visuals", "HighLight", "Enabled", true, function(a)
        Configurations.Visuals.HighLight.Enabled = a
    end)
    Menu.ColorPicker("Visuals", "HighLight", "Fill Color", MainColor, 0, function(a)
        Configurations.Visuals.HighLight.FillColor = a
    end)
    Menu.ColorPicker("Visuals", "HighLight", "Outline Color", Color3.fromRGB(255, 255, 255), 0, function(a)
        Configurations.Visuals.HighLight.OutLineColor = a
    end)
end

local TLBackTrackSection = Menu.Container("Visuals", "Clone Chams", "Right") do
    Menu.CheckBox("Visuals", "Clone Chams", "Enabled", true, function(a)
        Configurations.Visuals.BackTrack.Enabled = a
    end)
    Menu.Slider("Visuals", "Clone Chams", "Transparency", 0, 1, 0, "", 1, function(a)
        Configurations.Visuals.BackTrack.Transparency = a
    end)
    Menu.Slider("Visuals", "Clone Chams", "Duration", 0, 5, 0.1, "", 1, function(a)
        Configurations.Visuals.BackTrack.Duration = a
    end)
    Menu.ColorPicker("Visuals", "Clone Chams", "Color", MainColor, 0, function(a)
        Configurations.Visuals.BackTrack.Color = a
    end)
    Menu.ComboBox("Visuals", "Clone Chams", "Apply To", "Local Player", {"Local Player", "Target"}, function(a)
        Configurations.Visuals.BackTrack.ApplyTo = a
    end)
end

local HitDetectionSection = Menu.Container("Visuals", "Hit Detection", "Left") do
    Menu.CheckBox("Visuals", "Hit Detection", "Enabled", false, function(a)
        Configurations.Visuals.Hit_Detection.Enabled = a
    end)
    
    Menu.CheckBox("Visuals", "Hit Detection", "Hit Sound", false, function(a)
        Configurations.Visuals.Hit_Detection.Sound = a
    end)
    
    Menu.ComboBox("Visuals", "Hit Detection", "Sound To Play", "Rust", {"Bameware", "Bubble", "Pick", "Pop", "Rust", "Sans", "Fart", "Big", "Vine", "Bruh", "Skeet", "Neverlose", "Fatality", "Bonk", "Minecraft"}, function(self)
        Configurations.Visuals.Hit_Detection.HitSound = self
    end)
    
    Menu.CheckBox("Visuals", "Hit Detection", "Hit Chams", false, function(a)
        Configurations.Visuals.Hit_Detection.Clone = a
    end)
    
    Menu.CheckBox("Visuals", "Hit Detection", "Hit Logs", false, function(a)
        Configurations.Visuals.Hit_Detection.Notify = a
    end)
    
    Menu.CheckBox("Visuals", "Hit Detection", "Hit Effect", false, function(a)
        Configurations.Visuals.Hit_Detection.HitEffect = a
    end)
    
    Menu.ComboBox("Visuals", "Hit Detection", "Hit Effects Type", "Nova", {"Nova", "Confetti", "Cum", "Slash", "Atomic Slash", "Crescent Slash", "Cosmic Explosion"}, function(w)
        Configurations.Visuals.Hit_Detection.HitEffectType = w
    end)
end

local TracersSection = Menu.Container("Visuals","Bullet Tracers","Left") do
    Menu.CheckBox("Visuals","Bullet Tracers","Enabled",false,function(self)
        Configurations.Visuals.Bullet_Trails.Enabled = self
    end)
    
    Menu.ColorPicker("Visuals","Bullet Tracers","Color",MainColor,0,function(self)
        Configurations.Visuals.Bullet_Trails.Color = self
    end)
    
    Menu.Slider("Visuals", "Bullet Tracers", "Duration", 1, 5, 3, "", 1, function(a)
        Configurations.Visuals.Bullet_Trails.Duration = a
    end)
end

local ImpactSection = Menu.Container("Visuals","Bullet Impact","Left") do
    Menu.CheckBox("Visuals","Bullet Impact","Enabled",false,function(self)
        Configurations.Visuals.Bullet_Impacts.Enabled = self
    end)
    
    Menu.ColorPicker("Visuals","Bullet Impact","Color",MainColor,0,function(self)
        Configurations.Visuals.Bullet_Impacts.Color = self
    end)
    
    Menu.Slider("Visuals", "Bullet Impact", "Duration", 1, 5, 3, "", 1, function(a)
        Configurations.Visuals.Bullet_Impacts.Duration = a
    end)
    
    Menu.Slider("Visuals", "Bullet Impact", "Width", 0.1, 5, 0.25, "", 1, function(a)
        Configurations.Visuals.Bullet_Impactsl.Width = a
    end)
end

local WorldSection = Menu.Container("Visuals", "World", "Left") do
    Menu.CheckBox("Visuals", "World", "Enabled", falde, function(a)
        Configurations.Visuals.World.Enabled = a
    end)
    
    Menu.CheckBox("Visuals", "World", "Fog", true, function(a)
        Configurations.Visuals.World.Fog.Enabled = a
    end)
    
    Menu.ColorPicker("Visuals", "World", "Fog Color", MainColor, 0, function(a)
        Configurations.Visuals.World.Fog.Color = a
    end)
    
    Menu.Slider("Visuals", "World", "Fog Start", 1, 100, 1, "", 1, function(a)
        Configurations.Visuals.World.Fog.Start = a
    end)
    
    Menu.Slider("Visuals", "World", "Fog End", 1, 100, 1, "", 1, function(a)
        Configurations.Visuals.World.Fog.End = a
    end)
    
    Menu.CheckBox("Visuals", "World", "Ambient", true, function(a)
        Configurations.Visuals.World.Ambient.Enabled = a
    end)
    
    Menu.ColorPicker("Visuals", "World", "Ambient Color", MainColor, 0, function(a)
        Configurations.Visuals.World.Ambient.Color = a
    end)
    
    Menu.CheckBox("Visuals", "World", "Brightness", true, function(a)
        Configurations.Visuals.World.Brightness.Enabled = a
    end)
    
    Menu.Slider("Visuals", "World", "Brightness Amount", 0, 20, 1, "", 1, function(a)
        Configurations.Visuals.World.Brightness.Value = a
    end)
    
    Menu.CheckBox("Visuals", "World", "Clock Time", true, function(a)
        Configurations.Visuals.World.ClockTime.Enabled = a
    end)
    
    Menu.Slider("Visuals", "World", "Time (hrs / hours)", 0, 24, 1, "", 1, function(a)
        Configurations.Visuals.World.ClockTime.Value = a
    end)
    end
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "Swag Mode DH",
   Callback = function()
   loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-swag-mode-reborn-6870"))()
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "Bates AutoShoot",
   Callback = function()
   -- By ezterminals on discord/Tiktok Give credits or raided.
-- Beta, You may think this is bad, But Test it.
-- Version: TerminalWare V1
-- Change Sets if you like.
-- Bate Auto Shoot
-- 3%534:8;@“#
-- Any Copy Of This Script Will be taken down. And ACCOUNT suspended.
-- .gg/8yYZc4CHHp
-- If you see the owner change at any point it will be me
-- This is the original script and it always will be.
-- Coped, Ezterminals on TikTok follow me.
loadstring(game:HttpGet("https://raw.githubusercontent.com/Creatingtesting/BateAutoShoot/main/By/ezterminals"))()
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "NetWork Desync (Needs X Keybind)",
   Callback = function()
   local Key = "X"
local Enabled = false
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Client = Players.LocalPlayer

local MainThread = task.spawn(function()
    while true do
        if Enabled and Client.Character and Client.Character:FindFirstChild("HumanoidRootPart") then
            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", true)
            task.wait()
            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
        end

        task.wait()
    end
end)

UserInputService.InputBegan:Connect(function(Input)
    if UserInputService:GetFocusedTextBox() then
        return
    end

    if Input.KeyCode.Name == Key then
        Enabled = not Enabled

        if Enabled then
            setfflag("S2PhysicsSenderRate", 2)
        else
            setfflag("S2PhysicsSenderRate", 13)
            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
        end
    end
end)
   end,
})

local Button = ExploitsTab:CreateButton({
   Name = "Xora TP Walk",
   Callback = function()
   loadstring(Game:HttpGet("https://raw.githubusercontent.com/TheRealXORA/Roblox/refs/heads/Main/Scripts%20/Universal%20/Tpwalk.lua", true))()
   end,
})
